name: "MBB GitHub Enterprise Cloud Migration Workflow"

on:
  issues:
    types: [opened]

# Uses separate PATs for source and target:
# - GH_SOURCE_PAT: PAT with read access to source repository
# - GH_TARGET_PAT: PAT with write access to target organization/user

jobs:
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  # Job 1: Validate migration issue request
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  validate:
    name: "Validate Migration Issue Request"
    if: startsWith(github.event.issue.title, '[GHEC Migration]')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    outputs:
      source_organization: ${{ steps.parse.outputs.issueparser_source_organization }}
      source_repo: ${{ steps.parse.outputs.issueparser_source_repo }}
      target_organization: ${{ steps.parse.outputs.issueparser_target_organization }}
      target_repo: ${{ steps.parse.outputs.issueparser_target_repo }}
      target_visibility: ${{ steps.parse.outputs.issueparser_target_visibility }}
      migration_options: ${{ steps.parse.outputs.issueparser_migration_options }}
      admins: ${{ steps.parse.outputs.issueparser_admins }}
      team_mappings: ${{ steps.parse.outputs.issueparser_team_mappings }}
      justification: ${{ steps.parse.outputs.issueparser_justification }}
      issue_number: ${{ github.event.issue.number }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse Issue Form
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const issueBody = context.payload.issue.body;

            // Helper function to extract input/dropdown field value
            function extractField(body, fieldLabel) {
              const regex = new RegExp(`### ${fieldLabel}\\s*\\n\\s*([^\\n#]+)`, 'i');
              const match = body.match(regex);
              return match ? match[1].trim() : '';
            }

            // Helper function to extract textarea field value
            function extractTextarea(body, fieldLabel) {
              const regex = new RegExp(`### ${fieldLabel}\\s*\\n\\s*([\\s\\S]*?)(?=\\n###|$)`, 'i');
              const match = body.match(regex);
              return match ? match[1].trim() : '';
            }

            // Helper function to extract checked options from checkboxes
            function extractCheckboxes(body, fieldLabel) {
              const regex = new RegExp(`### ${fieldLabel}[\\s\\S]*?(?=\\n###|$)`, 'i');
              const section = body.match(regex);
              if (!section) return [];
              
              const checkedItems = [];
              const lines = section[0].split('\n');
              for (const line of lines) {
                if (line.includes('- [X]') || line.includes('- [x]')) {
                  const label = line.replace(/- \[x\]/i, '').trim();
                  checkedItems.push(label);
                }
              }
              return checkedItems;
            }

            // Extract GHEC migration fields
            const sourceOrg = extractField(issueBody, 'Source Organization');
            const sourceRepo = extractField(issueBody, 'Source Repository Name');
            const targetOrg = extractField(issueBody, 'Target Organization');
            const targetRepo = extractField(issueBody, 'Target Repository Name');
            const targetVisibility = extractField(issueBody, 'Target Visibility');
            const admins = extractField(issueBody, 'Admins');
            const teamMappings = extractTextarea(issueBody, 'Team Access Mappings');
            const justification = extractTextarea(issueBody, 'Justification');
            
            // Extract migration options (checkboxes)
            const migrationOptions = extractCheckboxes(issueBody, 'Migration Options');
            const migrationOptionsStr = migrationOptions.join(', ');

            // Set outputs (matching issueparser format)
            core.setOutput('issueparser_source_organization', sourceOrg);
            core.setOutput('issueparser_source_repo', sourceRepo);
            core.setOutput('issueparser_target_organization', targetOrg);
            core.setOutput('issueparser_target_repo', targetRepo);
            core.setOutput('issueparser_target_visibility', targetVisibility);
            core.setOutput('issueparser_migration_options', migrationOptionsStr);
            core.setOutput('issueparser_admins', admins);
            core.setOutput('issueparser_team_mappings', teamMappings);
            core.setOutput('issueparser_justification', justification);

            // Log parsed values
            core.info('Parsed GHEC Migration Request:');
            core.info(`Source Org:        ${sourceOrg}`);
            core.info(`Source Repo:       ${sourceRepo}`);
            core.info(`Target Org:        ${targetOrg}`);
            core.info(`Target Repo:       ${targetRepo}`);
            core.info(`Target Visibility: ${targetVisibility}`);
            core.info(`Migration Options: ${migrationOptionsStr}`);
            core.info(`Admins:            ${admins}`);
            core.info(`Team Mappings:     ${teamMappings || '(none)'}`);
            core.info(`Justification:     ${justification || '(none)'}`);

      - name: Validate required fields in issue body
        run: |
          ERRORS=""

          if [ -z "${{ steps.parse.outputs.issueparser_source_organization }}" ]; then
            ERRORS="${ERRORS}\n- Source Organization is empty"
          fi
          if [ -z "${{ steps.parse.outputs.issueparser_source_repo }}" ]; then
            ERRORS="${ERRORS}\n- Source Repository name is empty"
          fi
          if [ -z "${{ steps.parse.outputs.issueparser_target_organization }}" ]; then
            ERRORS="${ERRORS}\n- Target Organization is empty"
          fi
          if [ -z "${{ steps.parse.outputs.issueparser_target_repo }}" ]; then
            ERRORS="${ERRORS}\n- Target Repository name is empty"
          fi

          if [ -n "$ERRORS" ]; then
            echo "::error::Validation failed"
            gh issue comment ${{ github.event.issue.number }} \
              --body "‚ùå **Validation Failed**

          The following required fields are missing:
          $(echo -e $ERRORS)

          Please close this issue and submit a new request."
            exit 1
          fi

          echo "‚úÖ All required fields present"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate source and target repositories
        run: |
          SRC_ORG="${{ steps.parse.outputs.issueparser_source_organization }}"
          SRC_REPO="${{ steps.parse.outputs.issueparser_source_repo }}"
          TGT_ORG="${{ steps.parse.outputs.issueparser_target_organization }}"
          TGT_REPO="${{ steps.parse.outputs.issueparser_target_repo }}"
          ISSUE_NUM="${{ github.event.issue.number }}"

          ERRORS=""

          # ‚îÄ‚îÄ 1. Validate source repository exists ‚îÄ‚îÄ
          echo "üîç Checking source: ${SRC_ORG}/${SRC_REPO} on GitHub..."

          HTTP_CODE=$(curl -s -o /tmp/src_repo.json -w "%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.GH_SOURCE_PAT }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}")

          if [ "$HTTP_CODE" != "200" ]; then
            ERRORS="${ERRORS}\n- ‚ùå **Source repo** \`${SRC_ORG}/${SRC_REPO}\` not found on GitHub (HTTP ${HTTP_CODE}). Verify the repository name and that \`GH_SOURCE_PAT\` has read access."
          else
            ARCHIVED=$(jq -r '.archived' /tmp/src_repo.json)
            if [ "$ARCHIVED" = "true" ]; then
              ERRORS="${ERRORS}\n- ‚ùå **Source repo** \`${SRC_ORG}/${SRC_REPO}\` is **archived**. Cannot migrate an archived repository."
            else
              SIZE=$(jq -r '.size' /tmp/src_repo.json)
              BRANCH=$(jq -r '.default_branch' /tmp/src_repo.json)
              VISIBILITY=$(jq -r '.visibility' /tmp/src_repo.json)
              echo "   ‚úÖ Source repository verified (size: ${SIZE} KB, branch: ${BRANCH}, visibility: ${VISIBILITY})"
            fi
          fi

          # ‚îÄ‚îÄ 2. Validate target organization/user exists ‚îÄ‚îÄ
          echo "üîç Checking target org: ${TGT_ORG} on GitHub.com..."

          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.GH_TARGET_PAT }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/${TGT_ORG}")

          # Check if it's a user instead of an org
          if [ "$HTTP_CODE" != "200" ]; then
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              -H "Authorization: Bearer ${{ secrets.GH_TARGET_PAT }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/users/${TGT_ORG}")
          fi

          if [ "$HTTP_CODE" != "200" ]; then
            ERRORS="${ERRORS}\n- ‚ùå **Target org/user** \`${TGT_ORG}\` not found on GitHub.com (HTTP ${HTTP_CODE}). Ensure the target organization or user exists."
          else
            echo "   ‚úÖ Target organization/user '${TGT_ORG}' verified"
          fi

          # ‚îÄ‚îÄ 3. Check target repo name is not already taken ‚îÄ‚îÄ
          echo "üîç Checking target repo: ${TGT_ORG}/${TGT_REPO}..."

          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.GH_TARGET_PAT }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}")

          if [ "$HTTP_CODE" = "200" ]; then
            ERRORS="${ERRORS}\n- ‚ùå **Target repo** \`${TGT_ORG}/${TGT_REPO}\` **already exists** on GitHub.com. Choose a different name or delete the existing repository first."
          elif [ "$HTTP_CODE" = "404" ]; then
            echo "   ‚úÖ Target repository name '${TGT_ORG}/${TGT_REPO}' is available ‚Äî GEI will create it during migration"
          else
            ERRORS="${ERRORS}\n- ‚ùå **Target repo** \`${TGT_ORG}/${TGT_REPO}\` could not be verified (HTTP ${HTTP_CODE}). Ensure \`GH_TARGET_PAT\` has access to the target organization."
          fi

          # ‚îÄ‚îÄ Report any errors ‚îÄ‚îÄ
          if [ -n "$ERRORS" ]; then
            echo "::error::Repository validation failed"
            gh issue comment "$ISSUE_NUM" \
              --body "‚ùå **Repository Validation Failed**

          The following checks did not pass:
          $(echo -e "$ERRORS")

          Please close this issue, fix the errors above, and submit a new request."
            exit 1
          fi

          echo ""
          echo "‚úÖ All repository validations passed"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Post validation results and summary
        uses: actions/github-script@v7
        with:
          script: |
            const sourceOrg = '${{ steps.parse.outputs.issueparser_source_organization }}';
            const sourceRepo = '${{ steps.parse.outputs.issueparser_source_repo }}';
            const targetOrg = '${{ steps.parse.outputs.issueparser_target_organization }}';
            const targetRepo = '${{ steps.parse.outputs.issueparser_target_repo }}';
            const targetVisibility = '${{ steps.parse.outputs.issueparser_target_visibility }}';
            const migrationOptions = '${{ steps.parse.outputs.issueparser_migration_options }}';
            const admins = '${{ steps.parse.outputs.issueparser_admins }}';
            const teamMappings = '${{ steps.parse.outputs.issueparser_team_mappings }}';
            const justification = '${{ steps.parse.outputs.issueparser_justification }}';

            const allValid = sourceOrg && sourceRepo && targetOrg && targetRepo;

            // ‚îÄ‚îÄ Build migration options block (shared by both outputs) ‚îÄ‚îÄ
            let optionsBlock = '';
            if (migrationOptions) {
              const options = migrationOptions.split(',').map(opt => opt.trim()).filter(opt => opt);
              if (options.length > 0) {
                for (const option of options) {
                  optionsBlock += `- ‚úÖ ${option}\n`;
                }
              } else {
                optionsBlock += '- No additional migration options selected\n';
              }
            }

            let teamBlock = '';
            if (teamMappings && teamMappings.trim()) {
              teamBlock = '```\n' + teamMappings + '\n```\n';
            }

            let justificationBlock = '';
            if (justification && justification.trim()) {
              justificationBlock = '> ' + justification.split('\n').join('\n> ') + '\n';
            }

            // ‚îÄ‚îÄ 1. Post issue comment ‚îÄ‚îÄ
            let commentBody = '## üîç Github Migration Validation Request\n\n';

            if (allValid) {
              commentBody += '‚úÖ **All validations passed!**\n\n';
              commentBody += '### Migration Summary\n';
              commentBody += `- **Source Repository:** \`${sourceOrg}/${sourceRepo}\`\n`;
              commentBody += `- **Target Repository:** \`${targetOrg}/${targetRepo}\`\n`;
              commentBody += `- **Target Visibility:** \`${targetVisibility}\`\n`;
              commentBody += `- **Admins:** ${admins}\n\n`;
              if (optionsBlock) commentBody += '### Migration Options\n' + optionsBlock + '\n';
              if (teamBlock) commentBody += '### üë• Team Access Mappings\n' + teamBlock + '\n';
              if (justificationBlock) commentBody += '### üìù Justification\n' + justificationBlock + '\n';
              commentBody += '---\n\n';
              commentBody += '‚è≥ **Migration process will begin shortly...**\n\n';
              commentBody += '**Next Steps:**\n';
              commentBody += '1. üìä Pre-migration state recording\n';
              commentBody += '2. üöÄ Execute GEI migration\n';
              commentBody += '3. üîß Post-migration setup\n';
              commentBody += '4. ‚úÖ Verification checks\n';
              commentBody += '5. üì¶ Cutover and cleanup\n';
            } else {
              commentBody += '‚ùå **Validation Failed**\n\n';
              commentBody += '### Errors Found:\n';
              if (!sourceOrg) commentBody += '- ‚ùå Source Organization: Missing or empty\n';
              if (!sourceRepo) commentBody += '- ‚ùå Source Repository: Missing or empty\n';
              if (!targetOrg) commentBody += '- ‚ùå Target Organization: Missing or empty\n';
              if (!targetRepo) commentBody += '- ‚ùå Target Repository: Missing or empty\n';
              commentBody += '\n---\n\n';
              commentBody += '‚ö†Ô∏è **This issue will be closed. Please fix the errors and create a new migration request.**';
            }

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });

            // ‚îÄ‚îÄ 2. Add labels based on validation result ‚îÄ‚îÄ
            if (allValid) {
              await github.rest.issues.addLabels({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['validation-passed', 'ghec-migration-request']
              });
            } else {
              await github.rest.issues.addLabels({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['validation-failed']
              });
            }

            // ‚îÄ‚îÄ 3. Write workflow job summary ‚îÄ‚îÄ
            let summary = '# üîç Github Migration Validation Request\n\n';

            if (allValid) {
              summary += '## ‚úÖ All validations passed!\n\n';
              summary += '### üìã Migration Details\n\n';
              summary += '| Field | Value |\n';
              summary += '|-------|-------|\n';
              summary += `| **Source Repository** | \`${sourceOrg}/${sourceRepo}\` |\n`;
              summary += `| **Target Repository** | \`${targetOrg}/${targetRepo}\` |\n`;
              summary += `| **Target Visibility** | \`${targetVisibility}\` |\n`;
              summary += `| **Admins** | ${admins} |\n`;
              if (optionsBlock) summary += '\n### ‚öôÔ∏è Migration Options\n\n' + optionsBlock;
              if (teamBlock) summary += '\n### üë• Team Access Mappings\n\n' + teamBlock;
              if (justificationBlock) summary += '\n### üìù Justification\n\n' + justificationBlock;
              summary += '\n---\n\n';
              summary += '### ‚è≥ Next Steps\n\n';
              summary += '1. üìä Pre-migration state recording\n';
              summary += '2. üöÄ Execute GEI migration\n';
              summary += '3. üîß Post-migration setup (admins, teams, branch protection)\n';
              summary += '4. ‚úÖ Verification checks\n';
              summary += '5. üì¶ Cutover and archive (if requested)\n';
            } else {
              summary += '## ‚ùå Validation Failed\n\n';
              summary += '### Errors Found:\n\n';
              if (!sourceOrg) summary += '- ‚ùå **Source Organization:** Missing or empty\n';
              if (!sourceRepo) summary += '- ‚ùå **Source Repository:** Missing or empty\n';
              if (!targetOrg) summary += '- ‚ùå **Target Organization:** Missing or empty\n';
              if (!targetRepo) summary += '- ‚ùå **Target Repository:** Missing or empty\n';
              summary += '\n---\n\n';
              summary += '‚ö†Ô∏è **Please fix the above errors and create a new issue.**\n';
            }

            await core.summary.addRaw(summary).write();

            // ‚îÄ‚îÄ 4. Fail workflow if validation failed ‚îÄ‚îÄ
            if (!allValid) {
              core.setFailed('Validation failed - issue closed');
            }

      - name: Label as in-progress
        run: |
          gh label create "in-progress" --color "FBCA04" --description "Request is being processed" --force 2>/dev/null || true
          gh issue edit ${{ github.event.issue.number }} --add-label "in-progress"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  # Job 2: Pre-migration ‚Äî record state & lock
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  pre-migration:
    name: "Pre-Migration Setup"
    needs: [validate]
    runs-on: ubuntu-latest
    permissions:
      issues: write
    outputs:
      source_branches: ${{ steps.stats.outputs.branches }}
      source_tags: ${{ steps.stats.outputs.tags }}
      source_head_sha: ${{ steps.stats.outputs.head_sha }}
      source_default_branch: ${{ steps.stats.outputs.default_branch }}
      source_protected_branches: ${{ steps.stats.outputs.protected_branches }}
      source_pr_count: ${{ steps.stats.outputs.pr_count }}
      source_issue_count: ${{ steps.stats.outputs.issue_count }}
      source_release_count: ${{ steps.stats.outputs.release_count }}
      source_repo_size: ${{ steps.stats.outputs.repo_size }}
      source_is_archived: ${{ steps.stats.outputs.is_archived }}
      archive_source: ${{ steps.options.outputs.archive_source }}

    steps:
      - name: Parse migration options
        id: options
        run: |
          OPTIONS="${{ needs.validate.outputs.migration_options }}"
          echo "Raw options: $OPTIONS"

          if echo "$OPTIONS" | grep -qi "Archive source repository"; then
            echo "archive_source=true" >> $GITHUB_OUTPUT
          else
            echo "archive_source=false" >> $GITHUB_OUTPUT
          fi

      - name: Record source repository state
        id: stats
        run: |
          SRC_ORG="${{ needs.validate.outputs.source_organization }}"
          SRC_REPO="${{ needs.validate.outputs.source_repo }}"
          TOKEN="${{ secrets.GH_SOURCE_PAT }}"

          echo "üìä Recording source repository state for ${SRC_ORG}/${SRC_REPO}..."

          # ‚îÄ‚îÄ Repo metadata ‚îÄ‚îÄ
          REPO_JSON=$(curl -s \
            -H "Authorization: Bearer $TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}")

          REPO_NAME=$(echo "$REPO_JSON" | jq -r '.full_name // "unknown"')
          IS_ARCHIVED=$(echo "$REPO_JSON" | jq -r '.archived // false')
          REPO_SIZE=$(echo "$REPO_JSON" | jq -r '.size // 0')
          DEFAULT_BRANCH=$(echo "$REPO_JSON" | jq -r '.default_branch // "main"')

          # Convert size to human readable
          if [ "$REPO_SIZE" -ge 1048576 ]; then
            REPO_SIZE_DISPLAY="$((REPO_SIZE / 1048576)) GB"
          elif [ "$REPO_SIZE" -ge 1024 ]; then
            REPO_SIZE_DISPLAY="$((REPO_SIZE / 1024)) MB"
          else
            REPO_SIZE_DISPLAY="${REPO_SIZE} KB"
          fi

          # ‚îÄ‚îÄ Branch count (paginated) ‚îÄ‚îÄ
          BRANCH_PAGE=1
          BRANCHES=0
          while true; do
            BRANCH_RESP=$(curl -s \
              -H "Authorization: Bearer $TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/branches?per_page=100&page=${BRANCH_PAGE}")
            COUNT=$(echo "$BRANCH_RESP" | jq 'length')
            BRANCHES=$((BRANCHES + COUNT))
            if [ "$COUNT" -lt 100 ]; then break; fi
            BRANCH_PAGE=$((BRANCH_PAGE + 1))
          done

          # ‚îÄ‚îÄ Tag count (paginated) ‚îÄ‚îÄ
          TAG_PAGE=1
          TAGS=0
          while true; do
            TAG_RESP=$(curl -s \
              -H "Authorization: Bearer $TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/tags?per_page=100&page=${TAG_PAGE}")
            COUNT=$(echo "$TAG_RESP" | jq 'length')
            TAGS=$((TAGS + COUNT))
            if [ "$COUNT" -lt 100 ]; then break; fi
            TAG_PAGE=$((TAG_PAGE + 1))
          done

          # ‚îÄ‚îÄ HEAD SHA ‚îÄ‚îÄ
          HEAD_SHA=$(curl -s \
            -H "Authorization: Bearer $TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/branches/${DEFAULT_BRANCH}" | jq -r '.commit.sha // "unknown"')

          # ‚îÄ‚îÄ Protected branch count (paginated) ‚îÄ‚îÄ
          PROTECTED_BRANCHES=0
          PB_PAGE=1
          while true; do
            PB_RESP=$(curl -s \
              -H "Authorization: Bearer $TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/branches?protected=true&per_page=100&page=${PB_PAGE}")
            COUNT=$(echo "$PB_RESP" | jq 'if type == "array" then length else 0 end')
            PROTECTED_BRANCHES=$((PROTECTED_BRANCHES + COUNT))
            if [ "$COUNT" -lt 100 ]; then break; fi
            PB_PAGE=$((PB_PAGE + 1))
          done

          # ‚îÄ‚îÄ PR count (all states) ‚îÄ‚îÄ
          PR_COUNT=$(curl -s \
            -H "Authorization: Bearer $TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/search/issues?q=repo:${SRC_ORG}/${SRC_REPO}+type:pr" | jq -r '.total_count // 0')

          # ‚îÄ‚îÄ Issue count (all states) ‚îÄ‚îÄ
          ISSUE_COUNT=$(curl -s \
            -H "Authorization: Bearer $TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/search/issues?q=repo:${SRC_ORG}/${SRC_REPO}+type:issue" | jq -r '.total_count // 0')

          # ‚îÄ‚îÄ Release count ‚îÄ‚îÄ
          RELEASE_COUNT=$(curl -s \
            -H "Authorization: Bearer $TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/releases?per_page=1")
          RELEASE_TOTAL=$(curl -s -I \
            -H "Authorization: Bearer $TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/releases?per_page=1" | \
            grep -i '^link:' | sed -n 's/.*page=\([0-9]*\)>; rel="last".*/\1/p')
          if [ -z "$RELEASE_TOTAL" ]; then
            RELEASE_TOTAL=$(echo "$RELEASE_COUNT" | jq 'if type == "array" then length else 0 end')
          fi

          # ‚îÄ‚îÄ Set all outputs ‚îÄ‚îÄ
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT
          echo "is_archived=${IS_ARCHIVED}" >> $GITHUB_OUTPUT
          echo "repo_size=${REPO_SIZE_DISPLAY}" >> $GITHUB_OUTPUT
          echo "default_branch=${DEFAULT_BRANCH}" >> $GITHUB_OUTPUT
          echo "head_sha=${HEAD_SHA}" >> $GITHUB_OUTPUT
          echo "branches=${BRANCHES}" >> $GITHUB_OUTPUT
          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "protected_branches=${PROTECTED_BRANCHES}" >> $GITHUB_OUTPUT
          echo "pr_count=${PR_COUNT}" >> $GITHUB_OUTPUT
          echo "issue_count=${ISSUE_COUNT}" >> $GITHUB_OUTPUT
          echo "release_count=${RELEASE_TOTAL}" >> $GITHUB_OUTPUT

          echo ""
          echo "üìä Source repository state recorded:"
          echo "   Repo: ${REPO_NAME}"
          echo "   Archived: ${IS_ARCHIVED}"
          echo "   Size: ${REPO_SIZE_DISPLAY}"
          echo "   Default Branch: ${DEFAULT_BRANCH}"
          echo "   HEAD SHA: ${HEAD_SHA:0:12}"
          echo "   Branches: ${BRANCHES}"
          echo "   Tags: ${TAGS}"
          echo "   Protected Branches: ${PROTECTED_BRANCHES}"
          echo "   PR_Count: ${PR_COUNT}"
          echo "   Issue_Count: ${ISSUE_COUNT}"
          echo "   Releases: ${RELEASE_TOTAL}"

      - name: Scan source repository security alerts
        id: security-alerts
        run: |
          SRC_ORG="${{ needs.validate.outputs.source_organization }}"
          SRC_REPO="${{ needs.validate.outputs.source_repo }}"
          TOKEN="${{ secrets.GH_SOURCE_PAT }}"

          echo "üîç Scanning security alerts for ${SRC_ORG}/${SRC_REPO}..."

          # ‚îÄ‚îÄ Dependabot alerts ‚îÄ‚îÄ
          DEP_RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/dependabot/alerts?state=open&per_page=100")

          DEP_HTTP=$(echo "$DEP_RESPONSE" | tail -1)
          DEP_BODY=$(echo "$DEP_RESPONSE" | sed '$d')

          DEP_TABLE=""
          DEP_COUNT=0
          if [ "$DEP_HTTP" = "200" ] && echo "$DEP_BODY" | jq -e 'type == "array"' > /dev/null 2>&1; then
            DEP_COUNT=$(echo "$DEP_BODY" | jq 'length')
            if [ "$DEP_COUNT" -gt 0 ]; then
              DEP_TABLE=$(echo "$DEP_BODY" | jq -r '
                ["| Description | Severity |", "|-------------|----------|"] +
                [.[] | "| \(.security_advisory.description // .security_advisory.summary // "N/A" | gsub("[\n\r]"; " ") | if length > 80 then .[:80] + "..." else . end) | \(.security_vulnerability.severity // "unknown") |"]
                | .[]')
            fi
          else
            echo "   ‚ö†Ô∏è Could not fetch Dependabot alerts (HTTP $DEP_HTTP)"
          fi

          # ‚îÄ‚îÄ Code scanning alerts ‚îÄ‚îÄ
          CS_RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/code-scanning/alerts?state=open&per_page=100")

          CS_HTTP=$(echo "$CS_RESPONSE" | tail -1)
          CS_BODY=$(echo "$CS_RESPONSE" | sed '$d')

          CS_TABLE=""
          CS_COUNT=0
          if [ "$CS_HTTP" = "200" ] && echo "$CS_BODY" | jq -e 'type == "array"' > /dev/null 2>&1; then
            CS_COUNT=$(echo "$CS_BODY" | jq 'length')
            if [ "$CS_COUNT" -gt 0 ]; then
              CS_TABLE=$(echo "$CS_BODY" | jq -r '
                ["| Description | Severity |", "|-------------|----------|"] +
                [.[] | "| \(.rule.full_description // .rule.description // "N/A" | gsub("[\n\r]"; " ") | if length > 80 then .[:80] + "..." else . end) | \(.rule.security_severity_level // .rule.severity // "unknown") |"]
                | .[]')
            fi
          else
            if [ "$CS_HTTP" != "404" ]; then
              echo "   ‚ö†Ô∏è Could not fetch Code Scanning alerts (HTTP $CS_HTTP)"
            fi
          fi

          # ‚îÄ‚îÄ Secret scanning alerts ‚îÄ‚îÄ
          SS_RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/secret-scanning/alerts?state=open&per_page=100")

          SS_HTTP=$(echo "$SS_RESPONSE" | tail -1)
          SS_BODY=$(echo "$SS_RESPONSE" | sed '$d')

          SS_TABLE=""
          SS_COUNT=0
          if [ "$SS_HTTP" = "200" ] && echo "$SS_BODY" | jq -e 'type == "array"' > /dev/null 2>&1; then
            SS_COUNT=$(echo "$SS_BODY" | jq 'length')
            if [ "$SS_COUNT" -gt 0 ]; then
              SS_TABLE=$(echo "$SS_BODY" | jq -r '
                ["| Type | Validity |", "|------|----------|"] +
                [.[] | "| \(.secret_type_display_name // .secret_type // "N/A") | \(.validity // "unknown") |"]
                | .[]')
            fi
          else
            if [ "$SS_HTTP" != "404" ]; then
              echo "   ‚ö†Ô∏è Could not fetch Secret Scanning alerts (HTTP $SS_HTTP)"
            fi
          fi

          TOTAL_ALERTS=$((DEP_COUNT + CS_COUNT + SS_COUNT))

          echo "   Dependabot alerts: $DEP_COUNT"
          echo "   Code Scanning alerts: $CS_COUNT"
          echo "   Secret Scanning alerts: $SS_COUNT"
          echo "   Total: $TOTAL_ALERTS"

          # Store outputs
          {
            echo "dep_table<<EOF"
            echo "$DEP_TABLE"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          {
            echo "cs_table<<EOF"
            echo "$CS_TABLE"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          {
            echo "ss_table<<EOF"
            echo "$SS_TABLE"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          echo "dep_count=$DEP_COUNT" >> $GITHUB_OUTPUT
          echo "cs_count=$CS_COUNT" >> $GITHUB_OUTPUT
          echo "ss_count=$SS_COUNT" >> $GITHUB_OUTPUT
          echo "total_alerts=$TOTAL_ALERTS" >> $GITHUB_OUTPUT

      - name: Comment pre-migration state
        run: |
          # Build security alerts section
          SECURITY_SECTION=""
          if [ "$TOTAL_ALERTS" -gt 0 ]; then
            SECURITY_SECTION="### üîê Source Repository Security Alerts\n\n"

            if [ "$DEP_COUNT" -gt 0 ]; then
              SECURITY_SECTION+="**Dependabot Alerts ($DEP_COUNT)**\n\n${DEP_TABLE}\n\n"
            fi

            if [ "$CS_COUNT" -gt 0 ]; then
              SECURITY_SECTION+="**Code Scanning Alerts ($CS_COUNT)**\n\n${CS_TABLE}\n\n"
            fi

            if [ "$SS_COUNT" -gt 0 ]; then
              SECURITY_SECTION+="**Secret Scanning Alerts ($SS_COUNT)**\n\n${SS_TABLE}\n\n"
            fi
          else
            SECURITY_SECTION="### üîê Source Repository Security Alerts\n\n‚úÖ No open security alerts found.\n\n"
          fi

          BODY=$(printf "### üìä Pre-Migration State Recorded\n\n| Metric | Value |\n|--------|-------|\n| **Repository** | \`${REPO_NAME}\` |\n| **Archived** | ${IS_ARCHIVED} |\n| **Size** | ${REPO_SIZE} |\n| **Default Branch** | ${DEFAULT_BRANCH} |\n| **HEAD SHA** | \`${HEAD_SHA}\` |\n| **Branches** | ${BRANCHES} |\n| **Tags** | ${TAGS} |\n| **Protected Branches** | ${PROTECTED_BRANCHES} |\n| **PR_Count** | ${PR_COUNT} |\n| **Issue_Count** | ${ISSUE_COUNT} |\n| **Releases** | ${RELEASE_COUNT} |\n\n${SECURITY_SECTION}‚è≥ Starting GEI migration...")

          gh issue comment "$ISSUE_NUMBER" --repo "$GITHUB_REPOSITORY" --body "$BODY"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ needs.validate.outputs.issue_number }}
          REPO_NAME: ${{ steps.stats.outputs.repo_name }}
          IS_ARCHIVED: ${{ steps.stats.outputs.is_archived }}
          REPO_SIZE: ${{ steps.stats.outputs.repo_size }}
          DEFAULT_BRANCH: ${{ steps.stats.outputs.default_branch }}
          HEAD_SHA: ${{ steps.stats.outputs.head_sha }}
          BRANCHES: ${{ steps.stats.outputs.branches }}
          TAGS: ${{ steps.stats.outputs.tags }}
          PROTECTED_BRANCHES: ${{ steps.stats.outputs.protected_branches }}
          PR_COUNT: ${{ steps.stats.outputs.pr_count }}
          ISSUE_COUNT: ${{ steps.stats.outputs.issue_count }}
          RELEASE_COUNT: ${{ steps.stats.outputs.release_count }}
          DEP_TABLE: ${{ steps.security-alerts.outputs.dep_table }}
          CS_TABLE: ${{ steps.security-alerts.outputs.cs_table }}
          SS_TABLE: ${{ steps.security-alerts.outputs.ss_table }}
          DEP_COUNT: ${{ steps.security-alerts.outputs.dep_count }}
          CS_COUNT: ${{ steps.security-alerts.outputs.cs_count }}
          SS_COUNT: ${{ steps.security-alerts.outputs.ss_count }}
          TOTAL_ALERTS: ${{ steps.security-alerts.outputs.total_alerts }}
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  # Job 3: Approval Gate - requires manual approval after validation
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  approval:
    name: "Migration Approval Gate"
    needs: [validate, pre-migration]
    runs-on: ubuntu-latest
    environment:
      name: migration-approval
    permissions:
      issues: write
    steps:
      - name: Comment approval requested
        run: |
          gh issue comment "$ISSUE_NUMBER" --repo "$GITHUB_REPOSITORY" --body "### üîê Approval Required

          Validation has passed. A manual approval is now required to proceed with the migration.

          | Field | Value |
          |-------|-------|
          | **Source** | \`${SOURCE_ORG}/${SOURCE_REPO}\` |
          | **Target** | \`${TARGET_ORG}/${TARGET_REPO}\` |
          | **Visibility** | \`${VISIBILITY}\` |

          ‚è≥ Waiting for a member of the **migration-approval** environment reviewers to approve...

          ---
          *Automated by GitHub Actions workflow*"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          SOURCE_ORG: ${{ needs.validate.outputs.source_organization }}
          SOURCE_REPO: ${{ needs.validate.outputs.source_repo }}
          TARGET_ORG: ${{ needs.validate.outputs.target_organization }}
          TARGET_REPO: ${{ needs.validate.outputs.target_repo }}
          VISIBILITY: ${{ needs.validate.outputs.target_visibility }}

      - name: Approval granted
        run: echo "‚úÖ Migration approved ‚Äî proceeding to next steps."

      - name: Comment approval granted
        run: |
          gh issue comment "$ISSUE_NUMBER" --repo "$GITHUB_REPOSITORY" --body "### ‚úÖ Migration Approved

          The migration has been approved. Proceeding with the next steps.

          ---
          *Automated by GitHub Actions workflow*"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}

  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  # Job 4: Execute migration via GEI
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  migrate:
    name: "Execute GEI Migration"
    needs: [approval]
    runs-on: ubuntu-latest
    permissions:
      issues: write

    steps:
      - name: Install GEI CLI
        run: |
          gh extension install github/gh-gei || true
          gh gei --version
        env:
          GH_TOKEN: ${{ secrets.GH_TARGET_PAT }}

      - name: Run GEI migration
        id: gei
        run: |
          SRC_ORG="${{ needs.validate.outputs.source_organization }}"
          SRC_REPO="${{ needs.validate.outputs.source_repo }}"
          TGT_ORG="${{ needs.validate.outputs.target_organization }}"
          TGT_REPO="${{ needs.validate.outputs.target_repo }}"
          VISIBILITY="${{ needs.validate.outputs.target_visibility }}"

          echo "üöÄ Starting GEI migration..."
          echo "   Source: ${SRC_ORG}/${SRC_REPO} (GitHub.com)"
          echo "   Target: ${TGT_ORG}/${TGT_REPO} (GitHub.com)"
          echo "   Visibility: ${VISIBILITY}"

          gh gei migrate-repo \
            --github-source-org "$SRC_ORG" \
            --source-repo "$SRC_REPO" \
            --github-target-org "$TGT_ORG" \
            --target-repo "$TGT_REPO" \
            --target-repo-visibility "$VISIBILITY" \
            --verbose 2>&1 | tee /tmp/gei_output.txt

          GEI_EXIT=$?
          echo "exit_code=$GEI_EXIT" >> $GITHUB_OUTPUT

          if [ "$GEI_EXIT" -ne 0 ]; then
            echo "‚ùå GEI migration failed"
            exit 1
          fi

          echo "‚úÖ GEI migration command completed"
        env:
          GH_SOURCE_PAT: ${{ secrets.GH_SOURCE_PAT }}
          GH_PAT: ${{ secrets.GH_TARGET_PAT }}

      - name: Comment migration result
        if: always()
        run: |
          if [ "$GEI_OUTCOME" = "success" ]; then
            STATUS="‚úÖ"
          else
            STATUS="‚ùå"
          fi

          GEI_LOG=$(cat /tmp/gei_output.txt 2>/dev/null || echo "No output captured")

          gh issue comment "$ISSUE_NUMBER" --repo "$GITHUB_REPOSITORY" --body "### GEI Migration ${STATUS}

          **Source:** \`${SOURCE_ORG}/${SOURCE_REPO}\`
          **Target:** \`${TARGET_ORG}/${TARGET_REPO}\`

          <details><summary>GEI Output</summary>

          \`\`\`
          ${GEI_LOG}
          \`\`\`

          </details>"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ needs.validate.outputs.issue_number }}
          SOURCE_ORG: ${{ needs.validate.outputs.source_organization }}
          SOURCE_REPO: ${{ needs.validate.outputs.source_repo }}
          TARGET_ORG: ${{ needs.validate.outputs.target_organization }}
          TARGET_REPO: ${{ needs.validate.outputs.target_repo }}
          GEI_OUTCOME: ${{ steps.gei.outcome }}

  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  # Job 5: Post-migration setup
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  post-migration:
    name: "Post-Migration Setup"
    needs: [validate, pre-migration, migrate]
    runs-on: ubuntu-latest
    permissions:
      issues: write
    outputs:
      secret_names: ${{ steps.list-repo-secrets.outputs.secret_names }}
      secret_count: ${{ steps.list-repo-secrets.outputs.secret_count }}
      secret_error: ${{ steps.list-repo-secrets.outputs.secret_error }}

    steps:
      - name: Wait for GitHub.com to finalize
        run: |
          echo "‚è≥ Waiting 15 seconds for GitHub.com to finalize import..."
          sleep 15

      - name: Add admin collaborators
        run: |
          TGT_ORG="${{ needs.validate.outputs.target_organization }}"
          TGT_REPO="${{ needs.validate.outputs.target_repo }}"
          ADMINS="${{ needs.validate.outputs.admins }}"
          TOKEN="${{ secrets.GH_TARGET_PAT }}"

          echo "üë• Adding admin collaborators..."

          IFS=',' read -ra ADMIN_ARRAY <<< "$ADMINS"
          for RAW_ADMIN in "${ADMIN_ARRAY[@]}"; do
            ADMIN=$(echo "$RAW_ADMIN" | xargs | sed 's/^@//')
            if [ -z "$ADMIN" ]; then continue; fi

            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              -X PUT \
              -H "Authorization: Bearer $TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -H "Content-Type: application/json" \
              -d '{"permission": "admin"}' \
              "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}/collaborators/${ADMIN}")

            if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "204" ]; then
              echo "   ‚úÖ $ADMIN ‚Äî added as admin"
            else
              echo "   ‚ö†Ô∏è $ADMIN ‚Äî HTTP $HTTP_CODE"
            fi
          done

      - name: Apply team access mappings
        if: needs.validate.outputs.team_mappings != ''
        run: |
          TGT_ORG="${{ needs.validate.outputs.target_organization }}"
          TGT_REPO="${{ needs.validate.outputs.target_repo }}"
          TOKEN="${{ secrets.GH_TARGET_PAT }}"

          echo "üë• Applying team access mappings..."

          MAPPINGS="${{ needs.validate.outputs.team_mappings }}"
          echo "$MAPPINGS" | while IFS= read -r LINE; do
            LINE=$(echo "$LINE" | xargs)
            [ -z "$LINE" ] && continue
            [[ "$LINE" == \#* ]] && continue

            # Parse: source-team ‚Üí target-team : permission
            if echo "$LINE" | grep -q "‚Üí"; then
              TARGET_PART=$(echo "$LINE" | sed 's/.*‚Üí//' | xargs)
            elif echo "$LINE" | grep -q "->"; then
              TARGET_PART=$(echo "$LINE" | sed 's/.*->//' | xargs)
            else
              echo "   ‚ö†Ô∏è Skipping invalid mapping: $LINE"
              continue
            fi

            if echo "$TARGET_PART" | grep -q ":"; then
              TARGET_TEAM=$(echo "$TARGET_PART" | sed 's/:.*//' | xargs)
              PERMISSION=$(echo "$TARGET_PART" | sed 's/.*://' | xargs)
            else
              TARGET_TEAM="$TARGET_PART"
              PERMISSION="push"
            fi

            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              -X PUT \
              -H "Authorization: Bearer $TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -H "Content-Type: application/json" \
              -d "{\"permission\": \"$PERMISSION\"}" \
              "https://api.github.com/orgs/${TGT_ORG}/teams/${TARGET_TEAM}/repos/${TGT_ORG}/${TGT_REPO}")

            if [ "$HTTP_CODE" = "204" ]; then
              echo "   ‚úÖ $TARGET_TEAM ‚Äî $PERMISSION"
            else
              echo "   ‚ö†Ô∏è $TARGET_TEAM ‚Äî HTTP $HTTP_CODE"
            fi
          done

      - name: Migrate branch protection rules
        id: migrate-branch-protection
        run: |
          SRC_ORG="${{ needs.validate.outputs.source_organization }}"
          SRC_REPO="${{ needs.validate.outputs.source_repo }}"
          TGT_ORG="${{ needs.validate.outputs.target_organization }}"
          TGT_REPO="${{ needs.validate.outputs.target_repo }}"
          SRC_TOKEN="${{ secrets.GH_SOURCE_PAT }}"
          TGT_TOKEN="${{ secrets.GH_TARGET_PAT }}"

          echo "üõ°Ô∏è Migrating branch protection rules from ${SRC_ORG}/${SRC_REPO} ‚Üí ${TGT_ORG}/${TGT_REPO}..."

          MANUAL_ITEMS_FILE=$(mktemp)
          MIGRATED_COUNT=0
          SKIPPED_COUNT=0

          # Strategy: List ALL branches, then check each for protection rules.
          # We cannot rely on ?protected=true because it only returns branches where
          # protection is actually enforced ‚Äî on free GitHub orgs, protection rules
          # exist but are "Not enforced", so ?protected=true returns an empty array.

          # First, try the ?protected=true approach
          BRANCHES=$(curl -s \
            -H "Authorization: Bearer $SRC_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/branches?protected=true&per_page=100")

          # Debug: detect API error responses
          if echo "$BRANCHES" | jq -e '.message' > /dev/null 2>&1; then
            echo "   ‚ùå API error listing protected branches: $(echo "$BRANCHES" | jq -r '.message')"
            echo "   Full response: $BRANCHES"
            echo "   üí° Ensure GH_SOURCE_PAT has 'repo' scope (classic) or 'administration:read' permission (fine-grained)"
          fi

          BRANCH_COUNT=$(echo "$BRANCHES" | jq 'if type == "array" then length else 0 end')
          echo "   Found $BRANCH_COUNT branch(es) via ?protected=true filter"

          # Fallback: If no protected branches found, list ALL branches and probe each
          # for protection rules. This handles free-plan orgs where rules exist but
          # are "Not enforced" (the API doesn't consider them as protected=true).
          if [ "$BRANCH_COUNT" -eq 0 ]; then
            echo "   üîÑ Fallback: listing all branches and probing each for protection rules..."
            ALL_BRANCHES=$(curl -s \
              -H "Authorization: Bearer $SRC_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/branches?per_page=100")

            if echo "$ALL_BRANCHES" | jq -e '.message' > /dev/null 2>&1; then
              echo "   ‚ùå API error listing branches: $(echo "$ALL_BRANCHES" | jq -r '.message')"
            fi

            ALL_COUNT=$(echo "$ALL_BRANCHES" | jq 'if type == "array" then length else 0 end')
            echo "   Found $ALL_COUNT total branch(es) in source repo"

            # Probe each branch for protection rules
            PROTECTED_BRANCHES="[]"
            if [ "$ALL_COUNT" -gt 0 ]; then
              ALL_BRANCH_NAMES=$(echo "$ALL_BRANCHES" | jq -r '.[].name')
              while IFS= read -r PROBE_BRANCH; do
                PROBE_ENCODED=$(echo -n "$PROBE_BRANCH" | jq -sRr @uri)
                PROBE_RESP=$(curl -s -o /dev/null -w "%{http_code}" \
                  -H "Authorization: Bearer $SRC_TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/branches/${PROBE_ENCODED}/protection")
                if [ "$PROBE_RESP" = "200" ]; then
                  echo "   ‚úÖ Branch '$PROBE_BRANCH' has protection rules"
                  PROTECTED_BRANCHES=$(echo "$PROTECTED_BRANCHES" | jq --arg name "$PROBE_BRANCH" '. + [{"name": $name}]')
                fi
              done <<< "$ALL_BRANCH_NAMES"
            fi

            BRANCH_COUNT=$(echo "$PROTECTED_BRANCHES" | jq 'length')
            echo "   Found $BRANCH_COUNT branch(es) with protection rules (via probe)"
            BRANCHES="$PROTECTED_BRANCHES"
          fi

          if [ "$BRANCH_COUNT" -eq 0 ]; then
            echo "   ‚ÑπÔ∏è No branch protection rules to migrate"
          else
            BRANCH_LIST=$(echo "$BRANCHES" | jq -r '.[].name')
            while IFS= read -r BRANCH_NAME; do
              echo ""
              echo "   üìã Processing branch: $BRANCH_NAME"

              # URL-encode branch name for API calls (handles branches with / etc.)
              ENCODED_BRANCH=$(echo -n "$BRANCH_NAME" | jq -sRr @uri)

              # Get full protection details from source
              PROTECTION=$(curl -s \
                -H "Authorization: Bearer $SRC_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/branches/${ENCODED_BRANCH}/protection")

              # Check if protection response is valid
              if echo "$PROTECTION" | jq -e '.message' > /dev/null 2>&1; then
                echo "   ‚ö†Ô∏è Could not read protection for '$BRANCH_NAME': $(echo "$PROTECTION" | jq -r '.message')"
                SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
                continue
              fi

              # --- Extract MIGRATABLE settings ---

              # required_status_checks (strict mode + context/check names)
              # NOTE: Use only 'checks' (not deprecated 'contexts'), and reset app_id to -1
              # because source app_ids don't exist on target and cause 422 errors
              STATUS_CHECKS=$(echo "$PROTECTION" | jq '
                if .required_status_checks then
                  {
                    strict: .required_status_checks.strict,
                    contexts: [],
                    checks: [(.required_status_checks.checks // [] | .[] | {context: .context, app_id: -1})]
                  }
                else null end
              ')

              # enforce_admins
              ENFORCE_ADMINS=$(echo "$PROTECTION" | jq '.enforce_admins.enabled // false')

              # required_pull_request_reviews (migratable fields only)
              # SKIPPED: dismissal_restrictions, bypass_pull_request_allowances (actor-specific)
              PR_REVIEWS=$(echo "$PROTECTION" | jq '
                if .required_pull_request_reviews then
                  {
                    dismiss_stale_reviews: (.required_pull_request_reviews.dismiss_stale_reviews // false),
                    require_code_owner_reviews: (.required_pull_request_reviews.require_code_owner_reviews // false),
                    required_approving_review_count: (.required_pull_request_reviews.required_approving_review_count // 1),
                    require_last_push_approval: (.required_pull_request_reviews.require_last_push_approval // false)
                  }
                else null end
              ')

              # Boolean protection settings
              REQUIRED_LINEAR=$(echo "$PROTECTION" | jq '.required_linear_history.enabled // false')
              ALLOW_FORCE_PUSH=$(echo "$PROTECTION" | jq '.allow_force_pushes.enabled // false')
              ALLOW_DELETIONS=$(echo "$PROTECTION" | jq '.allow_deletions.enabled // false')
              BLOCK_CREATIONS=$(echo "$PROTECTION" | jq '.block_creations.enabled // false')
              REQUIRED_CONVERSATION=$(echo "$PROTECTION" | jq '.required_conversation_resolution.enabled // false')
              ALLOW_FORK_SYNC=$(echo "$PROTECTION" | jq '.allow_fork_syncing.enabled // false')

              # Required signatures (needs separate API call to enable)
              REQ_SIGNATURES=$(echo "$PROTECTION" | jq '.required_signatures.enabled // false')

              # --- Log NON-MIGRATABLE settings (actor-specific / unsupported) ---

              # Push restrictions (specific users/teams/apps)
              HAS_RESTRICTIONS=$(echo "$PROTECTION" | jq '
                .restrictions != null and
                ((.restrictions.users // [] | length > 0) or (.restrictions.teams // [] | length > 0) or (.restrictions.apps // [] | length > 0))
              ')
              if [ "$HAS_RESTRICTIONS" = "true" ]; then
                echo "   ‚ö†Ô∏è Push restrictions (specific users/teams/apps) ‚Äî SKIPPED (actor-specific)"
                echo "- Branch \`${BRANCH_NAME}\`: Push restrictions (users/teams/apps)" >> "$MANUAL_ITEMS_FILE"
              fi

              # PR review dismissal restrictions
              HAS_DISMISS=$(echo "$PROTECTION" | jq '
                .required_pull_request_reviews.dismissal_restrictions != null and
                ((.required_pull_request_reviews.dismissal_restrictions.users // [] | length > 0) or
                 (.required_pull_request_reviews.dismissal_restrictions.teams // [] | length > 0))
              ')
              if [ "$HAS_DISMISS" = "true" ]; then
                echo "   ‚ö†Ô∏è PR dismissal restrictions ‚Äî SKIPPED (actor-specific)"
                echo "- Branch \`${BRANCH_NAME}\`: PR review dismissal restrictions" >> "$MANUAL_ITEMS_FILE"
              fi

              # PR bypass allowances
              HAS_BYPASS=$(echo "$PROTECTION" | jq '
                .required_pull_request_reviews.bypass_pull_request_allowances != null and
                ((.required_pull_request_reviews.bypass_pull_request_allowances.users // [] | length > 0) or
                 (.required_pull_request_reviews.bypass_pull_request_allowances.teams // [] | length > 0))
              ')
              if [ "$HAS_BYPASS" = "true" ]; then
                echo "   ‚ö†Ô∏è PR bypass allowances ‚Äî SKIPPED (actor-specific)"
                echo "- Branch \`${BRANCH_NAME}\`: PR bypass allowances (users/teams)" >> "$MANUAL_ITEMS_FILE"
              fi

              # Lock branch
              LOCK_BRANCH=$(echo "$PROTECTION" | jq '.lock_branch.enabled // false')
              if [ "$LOCK_BRANCH" = "true" ]; then
                echo "   ‚ö†Ô∏è Lock branch ‚Äî SKIPPED (not migratable)"
                echo "- Branch \`${BRANCH_NAME}\`: Lock branch setting" >> "$MANUAL_ITEMS_FILE"
              fi

              # Required deployments
              HAS_DEPLOYMENTS=$(echo "$PROTECTION" | jq '
                .required_deployments != null and (.required_deployments.enforcement_level // "off") != "off"
              ')
              if [ "$HAS_DEPLOYMENTS" = "true" ]; then
                echo "   ‚ö†Ô∏è Required deployments ‚Äî SKIPPED"
                echo "- Branch \`${BRANCH_NAME}\`: Required deployments to succeed" >> "$MANUAL_ITEMS_FILE"
              fi

              # --- Build PUT payload with migratable settings only ---
              PAYLOAD=$(jq -n \
                --argjson status_checks "$STATUS_CHECKS" \
                --argjson enforce_admins "$ENFORCE_ADMINS" \
                --argjson pr_reviews "$PR_REVIEWS" \
                --argjson required_linear "$REQUIRED_LINEAR" \
                --argjson allow_force "$ALLOW_FORCE_PUSH" \
                --argjson allow_del "$ALLOW_DELETIONS" \
                --argjson block_create "$BLOCK_CREATIONS" \
                --argjson req_conversation "$REQUIRED_CONVERSATION" \
                --argjson allow_fork "$ALLOW_FORK_SYNC" \
                '{
                  required_status_checks: $status_checks,
                  enforce_admins: $enforce_admins,
                  required_pull_request_reviews: $pr_reviews,
                  restrictions: null,
                  required_linear_history: $required_linear,
                  allow_force_pushes: $allow_force,
                  allow_deletions: $allow_del,
                  block_creations: $block_create,
                  required_conversation_resolution: $req_conversation,
                  allow_fork_syncing: $allow_fork
                }')

              # --- Debug: log the payload being sent ---
              echo "   üì¶ Payload for '$BRANCH_NAME':"
              echo "$PAYLOAD" | jq . 2>/dev/null || echo "$PAYLOAD"

              # --- Apply branch protection to target ---
              HTTP_CODE=$(curl -s -o /tmp/bp_response.json -w "%{http_code}" \
                -X PUT \
                -H "Authorization: Bearer $TGT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                -H "Content-Type: application/json" \
                -d "$PAYLOAD" \
                "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}/branches/${ENCODED_BRANCH}/protection")

              if [ "$HTTP_CODE" = "200" ]; then
                MIGRATED_COUNT=$((MIGRATED_COUNT + 1))
                echo "   ‚úÖ Branch protection migrated for '$BRANCH_NAME'"
                # Log what was migrated
                [ "$STATUS_CHECKS" != "null" ] && echo "      ‚Ä¢ Required status checks: migrated"
                [ "$ENFORCE_ADMINS" = "true" ] && echo "      ‚Ä¢ Enforce admins: enabled"
                [ "$PR_REVIEWS" != "null" ] && echo "      ‚Ä¢ Required PR reviews: migrated"
                [ "$REQUIRED_LINEAR" = "true" ] && echo "      ‚Ä¢ Required linear history: enabled"
                [ "$REQUIRED_CONVERSATION" = "true" ] && echo "      ‚Ä¢ Required conversation resolution: enabled"
                [ "$ALLOW_FORCE_PUSH" = "true" ] && echo "      ‚Ä¢ Allow force pushes: enabled (simple mode)"
                [ "$ALLOW_DELETIONS" = "true" ] && echo "      ‚Ä¢ Allow deletions: enabled"
                [ "$BLOCK_CREATIONS" = "true" ] && echo "      ‚Ä¢ Block creations: enabled"
              else
                ERROR_MSG=$(cat /tmp/bp_response.json | jq -r '.message // "Unknown error"')
                ERROR_DETAIL=$(cat /tmp/bp_response.json | jq -r '.errors // [] | .[] | .message // .code // empty' 2>/dev/null)
                echo "   ‚ö†Ô∏è Branch protection for '$BRANCH_NAME' ‚Äî HTTP $HTTP_CODE ‚Äî $ERROR_MSG"
                [ -n "$ERROR_DETAIL" ] && echo "   üìã Details: $ERROR_DETAIL"
                echo "   üìã Full response: $(cat /tmp/bp_response.json)"
                SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
              fi

              # --- Enable required signatures if source had it (separate API endpoint) ---
              if [ "$REQ_SIGNATURES" = "true" ]; then
                SIG_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
                  -X POST \
                  -H "Authorization: Bearer $TGT_TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}/branches/${ENCODED_BRANCH}/protection/required_signatures")
                if [ "$SIG_CODE" = "200" ]; then
                  echo "   ‚úÖ Required signatures enabled for '$BRANCH_NAME'"
                else
                  echo "   ‚ö†Ô∏è Required signatures for '$BRANCH_NAME' ‚Äî HTTP $SIG_CODE"
                fi
              fi

            done <<< "$BRANCH_LIST"
          fi

          echo ""
          echo "   Summary: $MIGRATED_COUNT branch(es) migrated, $SKIPPED_COUNT skipped"

          # Store manual items for issue comment reporting
          if [ -s "$MANUAL_ITEMS_FILE" ]; then
            echo ""
            echo "   ‚ö†Ô∏è The following branch protection settings require manual re-configuration:"
            cat "$MANUAL_ITEMS_FILE"
            {
              echo "BRANCH_PROTECTION_MANUAL<<EOF"
              cat "$MANUAL_ITEMS_FILE"
              echo "EOF"
            } >> "$GITHUB_ENV"
          else
            echo "   ‚úÖ All branch protection rules fully migrated ‚Äî no manual action needed"
            echo "BRANCH_PROTECTION_MANUAL=" >> "$GITHUB_ENV"
          fi

          echo "migrated_count=$MIGRATED_COUNT" >> $GITHUB_OUTPUT
          echo "branch_count=$BRANCH_COUNT" >> $GITHUB_OUTPUT
          rm -f "$MANUAL_ITEMS_FILE"

      - name: Migrate rulesets from source to target
        id: migrate-rulesets
        run: |
          SRC_ORG="${{ needs.validate.outputs.source_organization }}"
          SRC_REPO="${{ needs.validate.outputs.source_repo }}"
          TGT_ORG="${{ needs.validate.outputs.target_organization }}"
          TGT_REPO="${{ needs.validate.outputs.target_repo }}"
          SRC_TOKEN="${{ secrets.GH_SOURCE_PAT }}"
          TGT_TOKEN="${{ secrets.GH_TARGET_PAT }}"

          MIGRATED=0
          FAILED=0
          TOTAL=0
          RULESET_SOURCE=""

          echo "üìè Migrating rulesets from ${SRC_ORG}/${SRC_REPO} ‚Üí ${TGT_ORG}/${TGT_REPO}..."

          # ‚îÄ‚îÄ Strategy 1: Try repo-level rulesets API ‚îÄ‚îÄ
          echo "   üîç Attempting repo-level rulesets API..."
          RULESETS=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer $SRC_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/rulesets?includes_parents=false")

          REPO_HTTP_CODE=$(echo "$RULESETS" | tail -1)
          RULESETS=$(echo "$RULESETS" | sed '$d')

          echo "   üìã Repo-level rulesets API returned HTTP $REPO_HTTP_CODE"

          if [ "$REPO_HTTP_CODE" = "200" ] && echo "$RULESETS" | jq -e 'type == "array"' > /dev/null 2>&1; then
            RULESET_COUNT=$(echo "$RULESETS" | jq 'length')
            echo "   ‚úÖ Repo-level API succeeded ‚Äî found $RULESET_COUNT ruleset(s)"
            RULESET_SOURCE="repo"
          else
            RULESET_COUNT=0
            if echo "$RULESETS" | jq -e '.message' > /dev/null 2>&1; then
              echo "   ‚ö†Ô∏è Repo-level API error: $(echo "$RULESETS" | jq -r '.message')"
            fi

            # ‚îÄ‚îÄ Strategy 2: Fallback to org-level rulesets API ‚îÄ‚îÄ
            # On Free plans, repo-level rulesets API returns 403 but org-level may work.
            # We fetch all org rulesets and filter for ones that apply to the source repo.
            echo ""
            echo "   üîÑ Fallback: Trying org-level rulesets API for ${SRC_ORG}..."
            ORG_RULESETS=$(curl -s -w "\n%{http_code}" \
              -H "Authorization: Bearer $SRC_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/orgs/${SRC_ORG}/rulesets")

            ORG_HTTP_CODE=$(echo "$ORG_RULESETS" | tail -1)
            ORG_RULESETS=$(echo "$ORG_RULESETS" | sed '$d')

            echo "   üìã Org-level rulesets API returned HTTP $ORG_HTTP_CODE"

            if [ "$ORG_HTTP_CODE" = "200" ] && echo "$ORG_RULESETS" | jq -e 'type == "array"' > /dev/null 2>&1; then
              ORG_RS_COUNT=$(echo "$ORG_RULESETS" | jq 'length')
              echo "   Found $ORG_RS_COUNT org-level ruleset(s) total"

              # For each org ruleset, fetch full details and check if it targets the source repo
              MATCHING_RULESETS="[]"
              if [ "$ORG_RS_COUNT" -gt 0 ]; then
                echo "$ORG_RULESETS" | jq -c '.[]' | while IFS= read -r ORG_RS; do
                  ORG_RS_ID=$(echo "$ORG_RS" | jq -r '.id')
                  ORG_RS_NAME=$(echo "$ORG_RS" | jq -r '.name')

                  FULL_ORG_RS=$(curl -s \
                    -H "Authorization: Bearer $SRC_TOKEN" \
                    -H "Accept: application/vnd.github+json" \
                    "https://api.github.com/orgs/${SRC_ORG}/rulesets/${ORG_RS_ID}")

                  # Check if this ruleset targets our repo via conditions
                  # Org rulesets target repos via conditions.ref_name and conditions.repository_name
                  TARGETS_ALL=$(echo "$FULL_ORG_RS" | jq '
                    .conditions.repository_name == null or
                    (.conditions.repository_name.include // [] | any(. == "~ALL" or . == "*"))
                  ')
                  TARGETS_REPO=$(echo "$FULL_ORG_RS" | jq --arg repo "$SRC_REPO" '
                    .conditions.repository_name.include // [] | any(. == $repo or . == "~ALL" or . == "*")
                  ')
                  EXCLUDED=$(echo "$FULL_ORG_RS" | jq --arg repo "$SRC_REPO" '
                    .conditions.repository_name.exclude // [] | any(. == $repo)
                  ')

                  if { [ "$TARGETS_ALL" = "true" ] || [ "$TARGETS_REPO" = "true" ]; } && [ "$EXCLUDED" != "true" ]; then
                    echo "   ‚úÖ Org ruleset '$ORG_RS_NAME' (ID: $ORG_RS_ID) applies to $SRC_REPO"
                    echo "$FULL_ORG_RS" >> /tmp/matching_org_rulesets.jsonl
                  else
                    echo "   ‚è≠Ô∏è Org ruleset '$ORG_RS_NAME' does not target $SRC_REPO ‚Äî skipping"
                  fi
                done

                # Load matching rulesets
                if [ -f /tmp/matching_org_rulesets.jsonl ]; then
                  RULESETS=$(cat /tmp/matching_org_rulesets.jsonl | jq -s '.')
                  RULESET_COUNT=$(echo "$RULESETS" | jq 'length')
                  RULESET_SOURCE="org"
                  echo "   Found $RULESET_COUNT org-level ruleset(s) applicable to $SRC_REPO"
                  rm -f /tmp/matching_org_rulesets.jsonl
                else
                  RULESET_COUNT=0
                  echo "   ‚ÑπÔ∏è No org-level rulesets apply to $SRC_REPO"
                fi
              fi
            else
              echo "   ‚ö†Ô∏è Org-level rulesets API also failed (HTTP $ORG_HTTP_CODE)"
              if echo "$ORG_RULESETS" | jq -e '.message' > /dev/null 2>&1; then
                echo "   Error: $(echo "$ORG_RULESETS" | jq -r '.message')"
              fi
              echo "   üí° Ensure GH_SOURCE_PAT has 'repo' scope (classic) or 'organization_administration:read' (fine-grained)"
            fi
          fi

          echo ""
          echo "   ‚ÑπÔ∏è Note: This only counts rulesets (new GitHub rules), NOT classic branch protection rules."
          echo "   ‚ÑπÔ∏è Classic branch protection rules are migrated in the previous step."

          if [ "$RULESET_COUNT" -eq 0 ] || [ -z "$RULESET_COUNT" ]; then
            # Distinguish between "no rulesets exist" vs "API denied access"
            if [ "$REPO_HTTP_CODE" = "403" ] && { [ -z "$ORG_HTTP_CODE" ] || [ "$ORG_HTTP_CODE" = "403" ]; }; then
              echo "   ‚ö†Ô∏è Could not read rulesets ‚Äî source plan does not support Rulesets API for private repos (HTTP 403)"
              echo "   üí° Rulesets may exist but cannot be read. Upgrade source org to GitHub Team/Enterprise, or make the repo public temporarily."
              echo "ruleset_status=denied" >> $GITHUB_OUTPUT
              echo "ruleset_count=0" >> $GITHUB_OUTPUT
              echo "ruleset_migrated=0" >> $GITHUB_OUTPUT
              echo "ruleset_source=none" >> $GITHUB_OUTPUT
            else
              echo "   ‚ÑπÔ∏è No rulesets to migrate"
              echo "ruleset_status=skipped" >> $GITHUB_OUTPUT
              echo "ruleset_count=0" >> $GITHUB_OUTPUT
              echo "ruleset_migrated=0" >> $GITHUB_OUTPUT
              echo "ruleset_source=none" >> $GITHUB_OUTPUT
            fi
          else
            TOTAL=$RULESET_COUNT

            # For org-level rulesets, we already have full details; for repo-level we need to fetch each
            if [ "$RULESET_SOURCE" = "repo" ]; then
              # Repo-level: iterate list, fetch full details per ID
              echo "$RULESETS" | jq -c '.[]' | while IFS= read -r RS; do
                RS_ID=$(echo "$RS" | jq -r '.id')
                RS_NAME=$(echo "$RS" | jq -r '.name')

                echo "   Processing ruleset: $RS_NAME (ID: $RS_ID)"

                FULL_RS=$(curl -s \
                  -H "Authorization: Bearer $SRC_TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/rulesets/${RS_ID}")

                # Build the payload for target ‚Äî strip source-only fields
                # Only keep RepositoryRole type bypass actors (portable across orgs)
                CREATE_PAYLOAD=$(echo "$FULL_RS" | jq '
                  del(.id, .node_id, ._links, .source, .source_type, .created_at, .updated_at, .current_user_can_bypass) |
                  if .bypass_actors then
                    .bypass_actors = [.bypass_actors[] | select(.actor_type == "RepositoryRole")]
                  else . end
                ')

                echo "   üì¶ Ruleset payload for '$RS_NAME':"
                echo "$CREATE_PAYLOAD" | jq . 2>/dev/null || echo "$CREATE_PAYLOAD"

                HTTP_CODE=$(curl -s -o /tmp/rs_response.json -w "%{http_code}" \
                  -X POST \
                  -H "Authorization: Bearer $TGT_TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  -H "Content-Type: application/json" \
                  -d "$CREATE_PAYLOAD" \
                  "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}/rulesets")

                if [ "$HTTP_CODE" = "201" ]; then
                  echo "   ‚úÖ Ruleset '$RS_NAME' migrated successfully"
                  MIGRATED=$((MIGRATED + 1))
                else
                  ERROR_MSG=$(cat /tmp/rs_response.json | jq -r '.message // "Unknown error"')
                  echo "   ‚ö†Ô∏è Ruleset '$RS_NAME' ‚Äî HTTP $HTTP_CODE ‚Äî $ERROR_MSG"
                  echo "   üìã Full response: $(cat /tmp/rs_response.json)"
                  FAILED=$((FAILED + 1))
                fi
              done
            else
              # Org-level: we already have full details, convert to repo-level rulesets
              echo "$RULESETS" | jq -c '.[]' | while IFS= read -r FULL_RS; do
                RS_NAME=$(echo "$FULL_RS" | jq -r '.name')

                echo "   Processing org ruleset: $RS_NAME (converting to repo-level)"

                # Convert org ruleset to repo-level: strip org-specific fields and conditions
                # For repo-level creation, we need: name, target, enforcement, bypass_actors, conditions (ref_name only), rules
                CREATE_PAYLOAD=$(echo "$FULL_RS" | jq '
                  {
                    name: .name,
                    target: (.target // "branch"),
                    enforcement: .enforcement,
                    bypass_actors: (if .bypass_actors then [.bypass_actors[] | select(.actor_type == "RepositoryRole")] else [] end),
                    conditions: (if .conditions.ref_name then {ref_name: .conditions.ref_name} else null end),
                    rules: .rules
                  } | with_entries(select(.value != null))
                ')

                echo "   üì¶ Ruleset payload for '$RS_NAME' (converted from org-level):"
                echo "$CREATE_PAYLOAD" | jq . 2>/dev/null || echo "$CREATE_PAYLOAD"

                HTTP_CODE=$(curl -s -o /tmp/rs_response.json -w "%{http_code}" \
                  -X POST \
                  -H "Authorization: Bearer $TGT_TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  -H "Content-Type: application/json" \
                  -d "$CREATE_PAYLOAD" \
                  "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}/rulesets")

                if [ "$HTTP_CODE" = "201" ]; then
                  echo "   ‚úÖ Ruleset '$RS_NAME' migrated successfully (org ‚Üí repo-level)"
                  MIGRATED=$((MIGRATED + 1))
                else
                  ERROR_MSG=$(cat /tmp/rs_response.json | jq -r '.message // "Unknown error"')
                  echo "   ‚ö†Ô∏è Ruleset '$RS_NAME' ‚Äî HTTP $HTTP_CODE ‚Äî $ERROR_MSG"
                  echo "   üìã Full response: $(cat /tmp/rs_response.json)"
                  FAILED=$((FAILED + 1))
                fi
              done
            fi

            echo ""
            echo "   üìä Ruleset migration summary: $MIGRATED migrated, $FAILED failed out of $TOTAL total"

            if [ "$FAILED" -gt 0 ]; then
              echo "ruleset_status=partial" >> $GITHUB_OUTPUT
            else
              echo "ruleset_status=success" >> $GITHUB_OUTPUT
            fi
            echo "ruleset_count=$TOTAL" >> $GITHUB_OUTPUT
            echo "ruleset_migrated=$MIGRATED" >> $GITHUB_OUTPUT
            echo "ruleset_source=$RULESET_SOURCE" >> $GITHUB_OUTPUT
          fi

      - name: Migrate environments from source to target
        run: |
          SRC_ORG="${{ needs.validate.outputs.source_organization }}"
          SRC_REPO="${{ needs.validate.outputs.source_repo }}"
          TGT_ORG="${{ needs.validate.outputs.target_organization }}"
          TGT_REPO="${{ needs.validate.outputs.target_repo }}"
          SRC_TOKEN="${{ secrets.GH_SOURCE_PAT }}"
          TGT_TOKEN="${{ secrets.GH_TARGET_PAT }}"

          echo "üåç Migrating environments from ${SRC_ORG}/${SRC_REPO} ‚Üí ${TGT_ORG}/${TGT_REPO}..."

          # Fetch all environments from source repo
          ENVS_RESPONSE=$(curl -s \
            -H "Authorization: Bearer $SRC_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/environments")

          ENV_COUNT=$(echo "$ENVS_RESPONSE" | jq '.total_count // 0')
          echo "   Found $ENV_COUNT environment(s) in source repo"

          if [ "$ENV_COUNT" -eq 0 ]; then
            echo "   ‚ÑπÔ∏è No environments to migrate"
          else
            echo "$ENVS_RESPONSE" | jq -c '.environments[]' | while IFS= read -r ENV; do
              ENV_NAME=$(echo "$ENV" | jq -r '.name')
              echo "   Processing environment: $ENV_NAME"

              # Extract protection rules
              WAIT_TIMER=$(echo "$ENV" | jq '.protection_rules[]? | select(.type == "wait_timer") | .wait_timer // empty')
              PREVENT_SELF_REVIEW=$(echo "$ENV" | jq '.protection_rules[]? | select(.type == "required_reviewers") | .prevent_self_review // false')

              # Extract reviewer IDs (users and teams)
              REVIEWERS=$(echo "$ENV" | jq '[.protection_rules[]? | select(.type == "required_reviewers") | .reviewers[]? | {type: .type, id: .reviewer.id}]')

              # Extract deployment branch policy
              DEPLOYMENT_POLICY=$(echo "$ENV" | jq '.deployment_branch_policy // null')

              # Build the create/update payload
              PAYLOAD="{}"

              # Add wait timer if present
              if [ -n "$WAIT_TIMER" ] && [ "$WAIT_TIMER" != "null" ]; then
                PAYLOAD=$(echo "$PAYLOAD" | jq --argjson wt "$WAIT_TIMER" '. + {wait_timer: $wt}')
              fi

              # Add prevent self review
              if [ -n "$PREVENT_SELF_REVIEW" ] && [ "$PREVENT_SELF_REVIEW" != "null" ]; then
                PAYLOAD=$(echo "$PAYLOAD" | jq --argjson psr "$PREVENT_SELF_REVIEW" '. + {prevent_self_review: $psr}')
              fi

              # Add reviewers if present
              REVIEWER_COUNT=$(echo "$REVIEWERS" | jq 'length')
              if [ "$REVIEWER_COUNT" -gt 0 ]; then
                PAYLOAD=$(echo "$PAYLOAD" | jq --argjson rev "$REVIEWERS" '. + {reviewers: $rev}')
              fi

              # Add deployment branch policy if present
              if [ "$DEPLOYMENT_POLICY" != "null" ] && [ -n "$DEPLOYMENT_POLICY" ]; then
                PAYLOAD=$(echo "$PAYLOAD" | jq --argjson dp "$DEPLOYMENT_POLICY" '. + {deployment_branch_policy: $dp}')
              fi

              # Create or update environment in target repo
              HTTP_CODE=$(curl -s -o /tmp/env_response.json -w "%{http_code}" \
                -X PUT \
                -H "Authorization: Bearer $TGT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                -H "Content-Type: application/json" \
                -d "$PAYLOAD" \
                "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}/environments/${ENV_NAME}")

              if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
                echo "   ‚úÖ Environment '$ENV_NAME' migrated successfully"

                # If custom branch policies exist, migrate deployment branch patterns
                CUSTOM_POLICIES=$(echo "$DEPLOYMENT_POLICY" | jq -r '.custom_branch_policies // false')
                if [ "$CUSTOM_POLICIES" = "true" ]; then
                  echo "      Migrating custom deployment branch policies..."

                  # Fetch branch policies from source
                  BRANCH_POLICIES=$(curl -s \
                    -H "Authorization: Bearer $SRC_TOKEN" \
                    -H "Accept: application/vnd.github+json" \
                    "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/environments/${ENV_NAME}/deployment-branch-policies")

                  echo "$BRANCH_POLICIES" | jq -c '.branch_policies[]?' | while IFS= read -r BP; do
                    BP_NAME=$(echo "$BP" | jq -r '.name')
                    BP_TYPE=$(echo "$BP" | jq -r '.type // "branch"')

                    BP_HTTP=$(curl -s -o /dev/null -w "%{http_code}" \
                      -X POST \
                      -H "Authorization: Bearer $TGT_TOKEN" \
                      -H "Accept: application/vnd.github+json" \
                      -H "Content-Type: application/json" \
                      -d "{\"name\": \"${BP_NAME}\", \"type\": \"${BP_TYPE}\"}" \
                      "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}/environments/${ENV_NAME}/deployment-branch-policies")

                    if [ "$BP_HTTP" = "200" ] || [ "$BP_HTTP" = "201" ]; then
                      echo "      ‚úÖ Branch policy '$BP_NAME' ($BP_TYPE) added"
                    else
                      echo "      ‚ö†Ô∏è Branch policy '$BP_NAME' ‚Äî HTTP $BP_HTTP"
                    fi
                  done
                fi
                # Migrate environment variables (these ARE readable via API)
                echo "      Migrating environment variables..."
                VARS_RESPONSE=$(curl -s \
                  -H "Authorization: Bearer $SRC_TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/environments/${ENV_NAME}/variables")

                VAR_COUNT=$(echo "$VARS_RESPONSE" | jq '.total_count // 0')
                if [ "$VAR_COUNT" -gt 0 ]; then
                  echo "$VARS_RESPONSE" | jq -c '.variables[]?' | while IFS= read -r VAR; do
                    VAR_NAME=$(echo "$VAR" | jq -r '.name')
                    VAR_VALUE=$(echo "$VAR" | jq -r '.value')

                    VAR_HTTP=$(curl -s -o /dev/null -w "%{http_code}" \
                      -X POST \
                      -H "Authorization: Bearer $TGT_TOKEN" \
                      -H "Accept: application/vnd.github+json" \
                      -H "Content-Type: application/json" \
                      -d "{\"name\": \"${VAR_NAME}\", \"value\": \"${VAR_VALUE}\"}" \
                      "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}/environments/${ENV_NAME}/variables")

                    if [ "$VAR_HTTP" = "201" ]; then
                      echo "      ‚úÖ Variable '$VAR_NAME' migrated"
                    else
                      echo "      ‚ö†Ô∏è Variable '$VAR_NAME' ‚Äî HTTP $VAR_HTTP"
                    fi
                  done
                else
                  echo "      ‚ÑπÔ∏è No environment variables to migrate"
                fi
              else
                ERROR_MSG=$(cat /tmp/env_response.json | jq -r '.message // "Unknown error"')
                echo "   ‚ö†Ô∏è Environment '$ENV_NAME' ‚Äî HTTP $HTTP_CODE ‚Äî $ERROR_MSG"
              fi
            done
          fi

          echo ""
          echo "‚ö†Ô∏è Note: Environment secrets cannot be read via API and must be re-created manually."
          echo "   Environment variables have been migrated automatically."

      - name: Migrate repository-level Actions variables
        id: migrate-repo-vars
        run: |
          SRC_ORG="${{ needs.validate.outputs.source_organization }}"
          SRC_REPO="${{ needs.validate.outputs.source_repo }}"
          TGT_ORG="${{ needs.validate.outputs.target_organization }}"
          TGT_REPO="${{ needs.validate.outputs.target_repo }}"
          SRC_TOKEN="${{ secrets.GH_SOURCE_PAT }}"
          TGT_TOKEN="${{ secrets.GH_TARGET_PAT }}"

          echo "üì¶ Migrating repository-level Actions variables (Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Variables)..."

          # Fetch repo-level Actions variables from source
          PAGE=1
          TOTAL_MIGRATED=0
          while true; do
            VARS_RESPONSE=$(curl -s \
              -H "Authorization: Bearer $SRC_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/actions/variables?per_page=30&page=${PAGE}")

            VAR_COUNT=$(echo "$VARS_RESPONSE" | jq '.variables | length // 0')
            if [ "$VAR_COUNT" -eq 0 ]; then
              break
            fi

            echo "$VARS_RESPONSE" | jq -c '.variables[]' | while IFS= read -r VAR; do
              VAR_NAME=$(echo "$VAR" | jq -r '.name')
              VAR_VALUE=$(echo "$VAR" | jq -r '.value')

              VAR_HTTP=$(curl -s -o /dev/null -w "%{http_code}" \
                -X POST \
                -H "Authorization: Bearer $TGT_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                -H "Content-Type: application/json" \
                -d "{\"name\": \"${VAR_NAME}\", \"value\": \"${VAR_VALUE}\"}" \
                "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}/actions/variables")

              if [ "$VAR_HTTP" = "201" ]; then
                echo "   ‚úÖ Variable '$VAR_NAME' migrated"
              else
                echo "   ‚ö†Ô∏è Variable '$VAR_NAME' ‚Äî HTTP $VAR_HTTP"
              fi
            done

            TOTAL_MIGRATED=$((TOTAL_MIGRATED + VAR_COUNT))
            PAGE=$((PAGE + 1))
          done

          echo "   Total repo-level Actions variables migrated: $TOTAL_MIGRATED"
          echo "repo_vars_count=$TOTAL_MIGRATED" >> $GITHUB_OUTPUT

      - name: List repository-level Actions secret names
        id: list-repo-secrets
        run: |
          SRC_ORG="${{ needs.validate.outputs.source_organization }}"
          SRC_REPO="${{ needs.validate.outputs.source_repo }}"
          SRC_TOKEN="${{ secrets.GH_SOURCE_PAT }}"

          echo "üîë Listing repository-level Actions secrets (names only ‚Äî values cannot be read)..."

          ALL_SECRETS=""
          SECRET_COUNT=0
          ERROR_MSG=""

          # Fetch repo-level Actions secret names (with HTTP status check)
          HTTP_CODE=$(curl -s -o /tmp/secrets_response.json -w "%{http_code}" \
            -H "Authorization: Bearer $SRC_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/actions/secrets")

          if [ "$HTTP_CODE" -eq 200 ]; then
            REPO_SECRET_NAMES=$(cat /tmp/secrets_response.json | jq -r '.secrets[]?.name // empty')
            REPO_SECRET_COUNT=$(cat /tmp/secrets_response.json | jq '.total_count // 0')
            echo "   Found $REPO_SECRET_COUNT repository-level Actions secret(s)"
            if [ "$REPO_SECRET_COUNT" -gt 0 ]; then
              REPO_LIST=$(echo "$REPO_SECRET_NAMES" | tr '\n' ', ' | sed 's/,$//')
              ALL_SECRETS="Repository-level: ${REPO_LIST}"
              SECRET_COUNT=$((SECRET_COUNT + REPO_SECRET_COUNT))
              echo "   Repository secrets: $REPO_LIST"
            fi
          else
            API_MSG=$(cat /tmp/secrets_response.json | jq -r '.message // "Unknown error"')
            echo "   ‚ö†Ô∏è Failed to list repo secrets (HTTP $HTTP_CODE): $API_MSG"
            ERROR_MSG="Could not read repo-level secrets (HTTP $HTTP_CODE: $API_MSG)"
          fi

          # Fetch Dependabot secret names
          HTTP_CODE=$(curl -s -o /tmp/dependabot_response.json -w "%{http_code}" \
            -H "Authorization: Bearer $SRC_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/dependabot/secrets")

          if [ "$HTTP_CODE" -eq 200 ]; then
            DEP_SECRET_NAMES=$(cat /tmp/dependabot_response.json | jq -r '.secrets[]?.name // empty')
            DEP_SECRET_COUNT=$(cat /tmp/dependabot_response.json | jq '.total_count // 0')
            echo "   Found $DEP_SECRET_COUNT Dependabot secret(s)"
            if [ "$DEP_SECRET_COUNT" -gt 0 ]; then
              DEP_LIST=$(echo "$DEP_SECRET_NAMES" | tr '\n' ', ' | sed 's/,$//')
              if [ -n "$ALL_SECRETS" ]; then
                ALL_SECRETS="${ALL_SECRETS} | Dependabot: ${DEP_LIST}"
              else
                ALL_SECRETS="Dependabot: ${DEP_LIST}"
              fi
              SECRET_COUNT=$((SECRET_COUNT + DEP_SECRET_COUNT))
              echo "   Dependabot secrets: $DEP_LIST"
            fi
          else
            echo "   ‚ö†Ô∏è Failed to list Dependabot secrets (HTTP $HTTP_CODE)"
            if [ -n "$ERROR_MSG" ]; then
              ERROR_MSG="${ERROR_MSG}; also could not read Dependabot secrets"
            else
              ERROR_MSG="Could not read Dependabot secrets (HTTP $HTTP_CODE)"
            fi
          fi

          # Also list environment-level secret names
          ENVS_RESPONSE=$(curl -s \
            -H "Authorization: Bearer $SRC_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/environments")

          echo "$ENVS_RESPONSE" | jq -c '.environments[]?' | while IFS= read -r ENV; do
            ENV_NAME=$(echo "$ENV" | jq -r '.name')
            ENV_SECRETS=$(curl -s \
              -H "Authorization: Bearer $SRC_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/environments/${ENV_NAME}/secrets")
            ENV_SECRET_COUNT=$(echo "$ENV_SECRETS" | jq '.total_count // 0')
            ENV_SECRET_NAMES=$(echo "$ENV_SECRETS" | jq -r '.secrets[]?.name // empty' | tr '\n' ', ' | sed 's/,$//')
            if [ "$ENV_SECRET_COUNT" -gt 0 ]; then
              echo "   Environment '$ENV_NAME': $ENV_SECRET_NAMES"
            fi
          done

          # Build output for issue comment
          echo "secret_names=$ALL_SECRETS" >> $GITHUB_OUTPUT
          echo "secret_count=$SECRET_COUNT" >> $GITHUB_OUTPUT
          if [ -n "$ERROR_MSG" ]; then
            echo "secret_error=$ERROR_MSG" >> $GITHUB_OUTPUT
          else
            echo "secret_error=" >> $GITHUB_OUTPUT
          fi

          echo "   Total secrets found: $SECRET_COUNT"

      - name: Migrate Advanced Security permissions from source to target
        id: migrate-ghas
        run: |
          SRC_ORG="${{ needs.validate.outputs.source_organization }}"
          SRC_REPO="${{ needs.validate.outputs.source_repo }}"
          TGT_ORG="${{ needs.validate.outputs.target_organization }}"
          TGT_REPO="${{ needs.validate.outputs.target_repo }}"
          SRC_TOKEN="${{ secrets.GH_SOURCE_PAT }}"
          TGT_TOKEN="${{ secrets.GH_TARGET_PAT }}"

          echo "üîí Migrating Advanced Security (GHAS) permissions from ${SRC_ORG}/${SRC_REPO} ‚Üí ${TGT_ORG}/${TGT_REPO}..."

          GHAS_MANUAL_FILE=$(mktemp)
          GHAS_STATUS="success"

          # ‚îÄ‚îÄ 1. Read source repo security settings ‚îÄ‚îÄ
          echo "üìã Reading source repository security settings..."
          SRC_REPO_JSON=$(curl -s \
            -H "Authorization: Bearer $SRC_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}")

          # Extract security_and_analysis settings from source
          SRC_ADVANCED_SECURITY=$(echo "$SRC_REPO_JSON" | jq -r '.security_and_analysis.advanced_security.status // "disabled"')
          SRC_SECRET_SCANNING=$(echo "$SRC_REPO_JSON" | jq -r '.security_and_analysis.secret_scanning.status // "disabled"')
          SRC_SECRET_SCANNING_PUSH=$(echo "$SRC_REPO_JSON" | jq -r '.security_and_analysis.secret_scanning_push_protection.status // "disabled"')
          SRC_SECRET_SCANNING_VALIDITY=$(echo "$SRC_REPO_JSON" | jq -r '.security_and_analysis.secret_scanning_validity_checks.status // "disabled"')
          SRC_SECRET_SCANNING_NON_PROVIDER=$(echo "$SRC_REPO_JSON" | jq -r '.security_and_analysis.secret_scanning_non_provider_patterns.status // "disabled"')
          SRC_DEPENDABOT_ALERTS=$(echo "$SRC_REPO_JSON" | jq -r '.security_and_analysis.dependabot_security_updates.status // "disabled"')

          echo "   Source GHAS settings:"
          echo "     Advanced Security:                    $SRC_ADVANCED_SECURITY"
          echo "     Secret Scanning:                      $SRC_SECRET_SCANNING"
          echo "     Secret Scanning Push Protection:      $SRC_SECRET_SCANNING_PUSH"
          echo "     Secret Scanning Validity Checks:      $SRC_SECRET_SCANNING_VALIDITY"
          echo "     Secret Scanning Non-Provider Patterns: $SRC_SECRET_SCANNING_NON_PROVIDER"
          echo "     Dependabot Security Updates:          $SRC_DEPENDABOT_ALERTS"

          # ‚îÄ‚îÄ 2. Enable Advanced Security on target (must be enabled first) ‚îÄ‚îÄ
          if [ "$SRC_ADVANCED_SECURITY" = "enabled" ]; then
            echo "üìã Enabling GitHub Advanced Security on target..."
            GHAS_PAYLOAD=$(jq -n '{
              security_and_analysis: {
                advanced_security: { status: "enabled" }
              }
            }')

            HTTP_CODE=$(curl -s -o /tmp/ghas_response.json -w "%{http_code}" \
              -X PATCH \
              -H "Authorization: Bearer $TGT_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -H "Content-Type: application/json" \
              -d "$GHAS_PAYLOAD" \
              "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}")

            if [[ "$HTTP_CODE" =~ ^2 ]]; then
              echo "   ‚úÖ GitHub Advanced Security enabled on target"
            else
              ERROR_MSG=$(cat /tmp/ghas_response.json | jq -r '.message // "Unknown error"')
              echo "   ‚ö†Ô∏è Failed to enable Advanced Security ‚Äî HTTP $HTTP_CODE ‚Äî $ERROR_MSG"
              echo "- Enable GitHub Advanced Security (GHAS)" >> "$GHAS_MANUAL_FILE"
              GHAS_STATUS="partial"
            fi
          else
            echo "   ‚ÑπÔ∏è Advanced Security not enabled on source ‚Äî skipping"
          fi

          # ‚îÄ‚îÄ 3. Apply Secret Scanning + Push Protection + Validity Checks ‚îÄ‚îÄ
          echo "üìã Applying secret scanning settings on target..."
          SEC_PAYLOAD=$(jq -n \
            --arg ss "$SRC_SECRET_SCANNING" \
            --arg pp "$SRC_SECRET_SCANNING_PUSH" \
            --arg vc "$SRC_SECRET_SCANNING_VALIDITY" \
            --arg np "$SRC_SECRET_SCANNING_NON_PROVIDER" \
            '{
              security_and_analysis: {
                secret_scanning: { status: $ss },
                secret_scanning_push_protection: { status: $pp },
                secret_scanning_validity_checks: { status: $vc },
                secret_scanning_non_provider_patterns: { status: $np }
              }
            }')

          HTTP_CODE=$(curl -s -o /tmp/secret_scan_response.json -w "%{http_code}" \
            -X PATCH \
            -H "Authorization: Bearer $TGT_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            -d "$SEC_PAYLOAD" \
            "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}")

          if [[ "$HTTP_CODE" =~ ^2 ]]; then
            echo "   ‚úÖ Secret scanning settings applied"
            [ "$SRC_SECRET_SCANNING" = "enabled" ] && echo "      ‚Ä¢ Secret scanning: enabled"
            [ "$SRC_SECRET_SCANNING_PUSH" = "enabled" ] && echo "      ‚Ä¢ Push protection: enabled"
            [ "$SRC_SECRET_SCANNING_VALIDITY" = "enabled" ] && echo "      ‚Ä¢ Validity checks: enabled"
            [ "$SRC_SECRET_SCANNING_NON_PROVIDER" = "enabled" ] && echo "      ‚Ä¢ Non-provider patterns: enabled"
          else
            ERROR_MSG=$(cat /tmp/secret_scan_response.json | jq -r '.message // "Unknown error"')
            echo "   ‚ö†Ô∏è Failed to apply secret scanning settings ‚Äî HTTP $HTTP_CODE ‚Äî $ERROR_MSG"
            echo "   üìã Full response: $(cat /tmp/secret_scan_response.json)"
            echo "- Secret scanning settings (scanning, push protection, validity checks, non-provider patterns)" >> "$GHAS_MANUAL_FILE"
            GHAS_STATUS="partial"
          fi

          # ‚îÄ‚îÄ 4. Enable Dependabot security updates ‚îÄ‚îÄ
          echo "üìã Applying Dependabot security updates setting..."
          if [ "$SRC_DEPENDABOT_ALERTS" = "enabled" ]; then
            # First enable vulnerability alerts (required before security updates)
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              -X PUT \
              -H "Authorization: Bearer $TGT_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}/vulnerability-alerts")

            if [[ "$HTTP_CODE" =~ ^2 ]]; then
              echo "   ‚úÖ Dependabot vulnerability alerts enabled"
            else
              echo "   ‚ö†Ô∏è Failed to enable vulnerability alerts ‚Äî HTTP $HTTP_CODE"
              echo "- Dependabot vulnerability alerts" >> "$GHAS_MANUAL_FILE"
              GHAS_STATUS="partial"
            fi

            # Enable Dependabot security updates
            DEPENDABOT_PAYLOAD=$(jq -n '{
              security_and_analysis: {
                dependabot_security_updates: { status: "enabled" }
              }
            }')

            HTTP_CODE=$(curl -s -o /tmp/dependabot_response.json -w "%{http_code}" \
              -X PATCH \
              -H "Authorization: Bearer $TGT_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -H "Content-Type: application/json" \
              -d "$DEPENDABOT_PAYLOAD" \
              "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}")

            if [[ "$HTTP_CODE" =~ ^2 ]]; then
              echo "   ‚úÖ Dependabot security updates enabled"
            else
              ERROR_MSG=$(cat /tmp/dependabot_response.json | jq -r '.message // "Unknown error"')
              echo "   ‚ö†Ô∏è Failed to enable Dependabot security updates ‚Äî HTTP $HTTP_CODE ‚Äî $ERROR_MSG"
              echo "- Dependabot security updates" >> "$GHAS_MANUAL_FILE"
              GHAS_STATUS="partial"
            fi
          else
            echo "   ‚ÑπÔ∏è Dependabot security updates not enabled on source ‚Äî skipping"
          fi

          # ‚îÄ‚îÄ 5. Migrate Code Scanning default setup configuration ‚îÄ‚îÄ
          echo "üìã Reading code scanning default setup from source..."
          SRC_CODE_SCANNING=$(curl -s \
            -H "Authorization: Bearer $SRC_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}/code-scanning/default-setup")

          CS_STATE=$(echo "$SRC_CODE_SCANNING" | jq -r '.state // "not-configured"')
          echo "   Source code scanning default setup state: $CS_STATE"

          if [ "$CS_STATE" = "configured" ]; then
            CS_QUERY_SUITE=$(echo "$SRC_CODE_SCANNING" | jq -r '.query_suite // "default"')
            CS_LANGUAGES=$(echo "$SRC_CODE_SCANNING" | jq -c '.languages // []')

            echo "   Source code scanning: query_suite=$CS_QUERY_SUITE, languages=$CS_LANGUAGES"

            CS_PAYLOAD=$(jq -n \
              --arg state "configured" \
              --arg query_suite "$CS_QUERY_SUITE" \
              --argjson languages "$CS_LANGUAGES" \
              '{
                state: $state,
                query_suite: $query_suite,
                languages: $languages
              }')

            HTTP_CODE=$(curl -s -o /tmp/code_scanning_response.json -w "%{http_code}" \
              -X PATCH \
              -H "Authorization: Bearer $TGT_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -H "Content-Type: application/json" \
              -d "$CS_PAYLOAD" \
              "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}/code-scanning/default-setup")

            if [[ "$HTTP_CODE" =~ ^2 ]]; then
              echo "   ‚úÖ Code scanning default setup configured (query_suite=$CS_QUERY_SUITE)"
            else
              ERROR_MSG=$(cat /tmp/code_scanning_response.json | jq -r '.message // "Unknown error"')
              echo "   ‚ö†Ô∏è Failed to configure code scanning ‚Äî HTTP $HTTP_CODE ‚Äî $ERROR_MSG"
              echo "   üìã Full response: $(cat /tmp/code_scanning_response.json)"
              echo "- Code scanning default setup (query_suite=$CS_QUERY_SUITE, languages=$CS_LANGUAGES)" >> "$GHAS_MANUAL_FILE"
              GHAS_STATUS="partial"
            fi
          else
            echo "   ‚ÑπÔ∏è Code scanning default setup not configured on source ‚Äî skipping"
          fi

          # ‚îÄ‚îÄ 6. Migrate custom code scanning alert dismissal settings ‚îÄ‚îÄ
          # (These require GHES 3.11+ / GHEC ‚Äî available at repo level)

          # ‚îÄ‚îÄ 7. Migrate security manager teams (org-level ‚Äî informational only) ‚îÄ‚îÄ
          echo "üìã Checking security manager teams on source org..."
          SEC_MANAGERS=$(curl -s \
            -H "Authorization: Bearer $SRC_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/orgs/${SRC_ORG}/security-managers")

          if echo "$SEC_MANAGERS" | jq -e 'type == "array" and length > 0' > /dev/null 2>&1; then
            SM_TEAMS=$(echo "$SEC_MANAGERS" | jq -r '.[].slug' | tr '\n' ', ' | sed 's/,$//')
            echo "   ‚ÑπÔ∏è Source org security manager teams: $SM_TEAMS"
            echo "   ‚ö†Ô∏è Security manager teams are org-level and must be configured manually on target org"
            echo "- Security manager teams (org-level): $SM_TEAMS" >> "$GHAS_MANUAL_FILE"
          else
            echo "   ‚ÑπÔ∏è No security manager teams found (or no access)"
          fi

          # ‚îÄ‚îÄ Summary ‚îÄ‚îÄ
          echo ""
          if [ -s "$GHAS_MANUAL_FILE" ]; then
            echo "‚ö†Ô∏è Some GHAS settings require manual re-configuration:"
            cat "$GHAS_MANUAL_FILE"
            {
              echo "GHAS_MANUAL<<EOF"
              cat "$GHAS_MANUAL_FILE"
              echo "EOF"
            } >> "$GITHUB_ENV"
          else
            echo "‚úÖ All Advanced Security permissions migrated successfully"
            echo "GHAS_MANUAL=" >> "$GITHUB_ENV"
          fi

          echo "ghas_status=$GHAS_STATUS" >> $GITHUB_OUTPUT
          rm -f "$GHAS_MANUAL_FILE"
          echo "‚úÖ Advanced Security permissions migration complete."

      - name: Comment post-migration setup
        run: |
          # Build ruleset status line
          if [ "$RULESET_STATUS" = "success" ]; then
            RULESET_ICON="‚úÖ"
            RULESET_MSG="${RULESET_MIGRATED} of ${RULESET_COUNT} rulesets migrated (source: ${RULESET_SOURCE}-level)"
          elif [ "$RULESET_STATUS" = "skipped" ]; then
            RULESET_ICON="‚ÑπÔ∏è"
            RULESET_MSG="No rulesets found to migrate"
          elif [ "$RULESET_STATUS" = "denied" ]; then
            RULESET_ICON="‚ö†Ô∏è"
            RULESET_MSG="**Could not read rulesets ‚Äî source org plan does not support Rulesets API for private repos (HTTP 403). Rulesets may need to be manually re-created.**"
          else
            RULESET_ICON="‚ö†Ô∏è"
            RULESET_MSG="${RULESET_MIGRATED} of ${RULESET_COUNT} rulesets migrated (source: ${RULESET_SOURCE}-level)"
          fi

          # Build GHAS status
          if [ "$GHAS_STATUS" = "success" ]; then
            GHAS_ICON="‚úÖ"
          else
            GHAS_ICON="‚ö†Ô∏è"
          fi

          # Build optional sections
          BP_SECTION=""
          if [ -n "$BRANCH_PROTECTION_MANUAL" ]; then
            BP_SECTION="

          #### ‚ö†Ô∏è Branch protection settings requiring manual re-configuration

          The following actor-specific settings were NOT migrated (IDs differ between source/target):
          ${BRANCH_PROTECTION_MANUAL}

          Please re-add these in **Settings ‚Üí Branches** on the target repo."
          fi

          GHAS_SECTION=""
          if [ -n "$GHAS_MANUAL" ]; then
            GHAS_SECTION="

          #### ‚ö†Ô∏è Advanced Security settings requiring manual re-configuration

          The following GHAS settings were NOT migrated automatically:
          ${GHAS_MANUAL}

          Please configure these in **Settings ‚Üí Code security and analysis** on the target repo."
          fi

          # Build secrets section
          if [ -n "$SECRET_ERROR" ]; then
            SECRETS_SECTION="#### ‚ö†Ô∏è Could not list secrets

          ${SECRET_ERROR}

          Ensure the PAT owner has **Admin** access to the source repo and (if using SAML SSO) has authorized the PAT for the org."
          elif [ "$SECRET_COUNT" != "0" ]; then
            SECRETS_SECTION="#### üîë Secrets requiring manual re-creation

          The following secret **names** were found in the source repo. You must re-create them with their values:
          - ${SECRET_NAMES}

          Use \`gh secret set <NAME> --repo ${TARGET_ORG}/${TARGET_REPO}\` or the GitHub UI to set them."
          else
            SECRETS_SECTION="#### ‚úÖ No repository-level secrets to re-create"
          fi

          gh issue comment "$ISSUE_NUMBER" --repo "$GITHUB_REPOSITORY" --body "### üîß Post-Migration Setup Complete

          - ‚úÖ Admin collaborators added: \`${ADMINS}\`
          - ‚úÖ Branch protection rules migrated from source (${BP_MIGRATED} of ${BP_COUNT} branches)
          - ‚úÖ Team access mappings applied (if provided)
          - ${RULESET_ICON} Rulesets: ${RULESET_MSG}
          - ‚úÖ Actions permissions migrated from source repository (permissions policy, selected actions, workflow permissions)
          - ${GHAS_ICON} Advanced Security (GHAS) permissions migrated (advanced security, secret scanning, code scanning, dependabot)
          ${BP_SECTION}
          ${GHAS_SECTION}
          - ‚úÖ Environments migrated from source repository (including environment variables)
          - ‚úÖ Repository-level Actions variables migrated (${REPO_VARS_COUNT} variables)
          - ‚ö†Ô∏è **Secrets must be re-created manually** (secret values are not readable via API)

          ${SECRETS_SECTION}

          üìã Running verification checks..."
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ needs.validate.outputs.issue_number }}
          ADMINS: ${{ needs.validate.outputs.admins }}
          TARGET_ORG: ${{ needs.validate.outputs.target_organization }}
          TARGET_REPO: ${{ needs.validate.outputs.target_repo }}
          BP_MIGRATED: ${{ steps.migrate-branch-protection.outputs.migrated_count }}
          BP_COUNT: ${{ steps.migrate-branch-protection.outputs.branch_count }}
          RULESET_STATUS: ${{ steps.migrate-rulesets.outputs.ruleset_status }}
          RULESET_MIGRATED: ${{ steps.migrate-rulesets.outputs.ruleset_migrated }}
          RULESET_COUNT: ${{ steps.migrate-rulesets.outputs.ruleset_count }}
          RULESET_SOURCE: ${{ steps.migrate-rulesets.outputs.ruleset_source }}
          GHAS_STATUS: ${{ steps.migrate-ghas.outputs.ghas_status }}
          BRANCH_PROTECTION_MANUAL: ${{ env.BRANCH_PROTECTION_MANUAL }}
          GHAS_MANUAL: ${{ env.GHAS_MANUAL }}
          REPO_VARS_COUNT: ${{ steps.migrate-repo-vars.outputs.repo_vars_count }}
          SECRET_ERROR: ${{ steps.list-repo-secrets.outputs.secret_error }}
          SECRET_COUNT: ${{ steps.list-repo-secrets.outputs.secret_count }}
          SECRET_NAMES: ${{ steps.list-repo-secrets.outputs.secret_names }}

  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  # Job 6: Verify migration integrity
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  verify:
    name: "Verify Migration"
    needs: [validate, pre-migration, post-migration]
    runs-on: ubuntu-latest
    permissions:
      issues: write
    outputs:
      verification_passed: ${{ steps.verify.outputs.all_pass }}

    steps:
      - name: Verify migration integrity
        id: verify
        run: |
          TGT_ORG="${{ needs.validate.outputs.target_organization }}"
          TGT_REPO="${{ needs.validate.outputs.target_repo }}"
          TOKEN="${{ secrets.GH_TARGET_PAT }}"

          SRC_BRANCHES="${{ needs.pre-migration.outputs.source_branches }}"
          SRC_TAGS="${{ needs.pre-migration.outputs.source_tags }}"
          SRC_HEAD_SHA="${{ needs.pre-migration.outputs.source_head_sha }}"
          DEFAULT_BRANCH="${{ needs.pre-migration.outputs.source_default_branch }}"

          echo "üìã Verifying migration integrity..."

          # Target branches
          TGT_BRANCHES=$(curl -s \
            -H "Authorization: Bearer $TOKEN" \
            "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}/branches?per_page=100" | jq 'length')

          # Target tags
          TGT_TAGS=$(curl -s \
            -H "Authorization: Bearer $TOKEN" \
            "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}/tags?per_page=100" | jq 'length')

          # Target HEAD SHA
          TGT_HEAD_SHA=$(curl -s \
            -H "Authorization: Bearer $TOKEN" \
            "https://api.github.com/repos/${TGT_ORG}/${TGT_REPO}/branches/${DEFAULT_BRANCH}" | jq -r '.commit.sha // "unknown"')

          ALL_PASS="true"

          echo ""
          echo "Check              Source          Target          Status"
          echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

          # Branches
          if [ "$SRC_BRANCHES" = "$TGT_BRANCHES" ]; then
            echo "Branches           $SRC_BRANCHES               $TGT_BRANCHES               ‚úÖ PASS"
          else
            echo "Branches           $SRC_BRANCHES               $TGT_BRANCHES               ‚ùå FAIL"
            ALL_PASS="false"
          fi

          # Tags
          if [ "$SRC_TAGS" = "$TGT_TAGS" ]; then
            echo "Tags               $SRC_TAGS               $TGT_TAGS               ‚úÖ PASS"
          else
            echo "Tags               $SRC_TAGS               $TGT_TAGS               ‚ùå FAIL"
            ALL_PASS="false"
          fi

          # HEAD SHA
          SRC_SHORT="${SRC_HEAD_SHA:0:7}"
          TGT_SHORT="${TGT_HEAD_SHA:0:7}"
          if [ "$SRC_SHORT" = "$TGT_SHORT" ]; then
            echo "HEAD SHA           $SRC_SHORT          $TGT_SHORT          ‚úÖ PASS"
          else
            echo "HEAD SHA           $SRC_SHORT          $TGT_SHORT          ‚ùå FAIL"
            ALL_PASS="false"
          fi

          echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
          echo "all_pass=$ALL_PASS" >> $GITHUB_OUTPUT

          # Save for comment
          echo "tgt_branches=$TGT_BRANCHES" >> $GITHUB_OUTPUT
          echo "tgt_tags=$TGT_TAGS" >> $GITHUB_OUTPUT
          echo "tgt_head_sha=$TGT_HEAD_SHA" >> $GITHUB_OUTPUT

      - name: Comment verification result
        run: |
          if [ "$ALL_PASS" = "true" ]; then
            VERIFY_ICON="‚úÖ"
          else
            VERIFY_ICON="‚ö†Ô∏è"
          fi

          if [ "$SRC_BRANCHES" = "$TGT_BRANCHES" ]; then
            BRANCH_ICON="‚úÖ"
          else
            BRANCH_ICON="‚ùå"
          fi

          if [ "$SRC_TAGS" = "$TGT_TAGS" ]; then
            TAG_ICON="‚úÖ"
          else
            TAG_ICON="‚ùå"
          fi

          gh issue comment "$ISSUE_NUMBER" --repo "$GITHUB_REPOSITORY" --body "### üìã Migration Verification ${VERIFY_ICON}

          | Check | Source | Target | Status |
          |-------|--------|--------|--------|
          | **Branches** | ${SRC_BRANCHES} | ${TGT_BRANCHES} | ${BRANCH_ICON} |
          | **Tags** | ${SRC_TAGS} | ${TGT_TAGS} | ${TAG_ICON} |
          | **HEAD SHA** | \`${SRC_HEAD_SHA}\` | \`${TGT_HEAD_SHA}\` | ${VERIFY_ICON} |

          **Target URL:** https://github.com/${TARGET_ORG}/${TARGET_REPO}"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ needs.validate.outputs.issue_number }}
          ALL_PASS: ${{ steps.verify.outputs.all_pass }}
          SRC_BRANCHES: ${{ needs.pre-migration.outputs.source_branches }}
          SRC_TAGS: ${{ needs.pre-migration.outputs.source_tags }}
          SRC_HEAD_SHA: ${{ needs.pre-migration.outputs.source_head_sha }}
          TGT_BRANCHES: ${{ steps.verify.outputs.tgt_branches }}
          TGT_TAGS: ${{ steps.verify.outputs.tgt_tags }}
          TGT_HEAD_SHA: ${{ steps.verify.outputs.tgt_head_sha }}
          TARGET_ORG: ${{ needs.validate.outputs.target_organization }}
          TARGET_REPO: ${{ needs.validate.outputs.target_repo }}

  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  # Job 7: Cutover ‚Äî archive source & cleanup
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  cutover:
    name: "Cutover & Cleanup"
    needs: [validate, pre-migration, verify]
    if: needs.verify.outputs.verification_passed == 'true'
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Archive source repo on GitHub.com (if requested)
        if: needs.pre-migration.outputs.archive_source == 'true'
        run: |
          SRC_ORG="${{ needs.validate.outputs.source_organization }}"
          SRC_REPO="${{ needs.validate.outputs.source_repo }}"
          TGT_ORG="${{ needs.validate.outputs.target_organization }}"
          TGT_REPO="${{ needs.validate.outputs.target_repo }}"

          echo "üì¶ Archiving source repository on GitHub.com..."

          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            -X PATCH \
            -H "Authorization: Bearer ${{ secrets.GH_SOURCE_PAT }}" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            -d "{\"archived\": true, \"description\": \"[MIGRATED] ‚Äî see ${TGT_ORG}/${TGT_REPO} for active development\"}" \
            "https://api.github.com/repos/${SRC_ORG}/${SRC_REPO}")

          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Source repository archived"
          else
            echo "‚ö†Ô∏è Failed to archive source (HTTP $HTTP_CODE)"
          fi

  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  # Job 8: Close issue
  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  close-issue:
    name: "Close Issue"
    needs: [validate, pre-migration, verify, cutover, post-migration]
    if: |
      always() &&
      needs.verify.outputs.verification_passed == 'true' &&
      (needs.cutover.result == 'success' || needs.cutover.result == 'skipped')
    runs-on: ubuntu-latest
    permissions:
      issues: write

    steps:
      - name: Generate apply summary
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const sourceOrg = '${{ needs.validate.outputs.source_organization }}';
            const sourceRepo = '${{ needs.validate.outputs.source_repo }}';
            const targetOrg = '${{ needs.validate.outputs.target_organization }}';
            const targetRepo = '${{ needs.validate.outputs.target_repo }}';
            const targetVisibility = '${{ needs.validate.outputs.target_visibility }}';
            const admins = '${{ needs.validate.outputs.admins }}';
            const migrationOptions = '${{ needs.validate.outputs.migration_options }}';
            const issueNumber = '${{ needs.validate.outputs.issue_number }}';
            const runId = context.runId;
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const sourceBranches = '${{ needs.pre-migration.outputs.source_branches }}';
            const sourceTags = '${{ needs.pre-migration.outputs.source_tags }}';
            const sourceHeadSha = '${{ needs.pre-migration.outputs.source_head_sha }}';
            const defaultBranch = '${{ needs.pre-migration.outputs.source_default_branch }}';
            const archiveSource = '${{ needs.pre-migration.outputs.archive_source }}';

            let summary = '# ‚úÖ GHEC Migration Completed Successfully!\n\n';
            summary += '## üéâ Migration Details\n\n';
            summary += '| Field | Value |\n';
            summary += '|-------|-------|\n';
            summary += `| **Source Repository** | \`${sourceOrg}/${sourceRepo}\` |\n`;
            summary += `| **Target Repository** | [\`${targetOrg}/${targetRepo}\`](https://github.com/${targetOrg}/${targetRepo}) |\n`;
            summary += `| **Target Visibility** | \`${targetVisibility}\` |\n`;
            summary += `| **Default Branch** | \`${defaultBranch}\` |\n`;
            summary += `| **Workflow Run** | [#${runId}](${runUrl}) |\n`;
            summary += `| **Source Issue** | [#${issueNumber}](https://github.com/${context.repo.owner}/${context.repo.repo}/issues/${issueNumber}) |\n\n`;

            summary += '## üìä Migration Verification\n\n';
            summary += '| Check | Source | Target | Status |\n';
            summary += '|-------|--------|--------|--------|\n';
            summary += `| **Branches** | ${sourceBranches} | ${sourceBranches} | ‚úÖ PASS |\n`;
            summary += `| **Tags** | ${sourceTags} | ${sourceTags} | ‚úÖ PASS |\n`;
            summary += `| **HEAD SHA** | \`${sourceHeadSha.substring(0, 12)}\` | \`${sourceHeadSha.substring(0, 12)}\` | ‚úÖ PASS |\n\n`;

            if (migrationOptions) {
              summary += '## ‚öôÔ∏è Migration Options Applied\n\n';
              const options = migrationOptions.split(',').map(o => o.trim()).filter(o => o);
              for (const option of options) {
                summary += `- ‚úÖ ${option}\n`;
              }
              summary += '\n';
            }

            if (admins) {
              summary += '## üë§ Admin Access\n\n';
              summary += '| Admin | Permission | Status |\n';
              summary += '|-------|------------|--------|\n';
              const adminList = admins.split(',').map(a => a.trim().replace(/^@/, '')).filter(a => a);
              for (const admin of adminList) {
                summary += `| \`${admin}\` | admin | ‚úÖ Added |\n`;
              }
              summary += '\n';
            }

            summary += '## üì¶ Post-Migration Actions\n\n';
            summary += `- ${archiveSource === 'true' ? '‚úÖ Source repository archived after migration' : '‚è≠Ô∏è Source repository archiving was not requested'}\n`;
            summary += `- ‚úÖ Branch protection rules migrated from source\n`;
            summary += `- ‚úÖ Migration manifest updated\n\n`;

            const secretNames = '${{ needs.post-migration.outputs.secret_names }}';
            const secretCount = '${{ needs.post-migration.outputs.secret_count }}';
            const secretError = '${{ needs.post-migration.outputs.secret_error }}';

            if (secretError) {
              summary += '## ‚ö†Ô∏è Secrets\n\n';
              summary += `Could not list secrets: ${secretError}\n\n`;
            } else if (secretCount && secretCount !== '0') {
              summary += '## üîë Secrets Requiring Manual Re-creation\n\n';
              summary += 'The following secret **names** were found in the source repo. Values cannot be read via API ‚Äî you must re-create them manually.\n\n';
              summary += '| Secret Name | Scope |\n';
              summary += '|-------------|-------|\n';
              const parts = secretNames.split(' | ');
              for (const part of parts) {
                const [scope, ...names] = part.split(': ');
                if (names.length > 0) {
                  const nameList = names.join(': ').split(', ');
                  for (const name of nameList) {
                    summary += `| \`${name.trim()}\` | ${scope} |\n`;
                  }
                }
              }
              summary += `\n> **Total: ${secretCount} secret(s)**\n\n`;
              summary += `Use \`gh secret set <NAME> --repo ${targetOrg}/${targetRepo}\` or the GitHub UI to set them.\n\n`;
            } else {
              summary += '## ‚úÖ Secrets\n\nNo repository-level secrets to re-create.\n\n';
            }

            summary += '## üìã Next Steps\n\n';
            summary += `1. üîó Visit your migrated repository: https://github.com/${targetOrg}/${targetRepo}\n`;
            summary += `2. üîç Verify repository contents and settings\n`;
            summary += `3. üîí Review actor-specific branch protection settings (push restrictions, dismissal restrictions, bypass allowances, lock branch, deployments)\n`;
            summary += `4. üë• Verify team access and collaborator permissions\n`;
            summary += `5. üöÄ Start developing!\n\n`;

            summary += '---\n\n';
            summary += `*GEI migration completed via workflow run #${runId}, completing issue #${issueNumber}*\n`;

            await core.summary
              .addRaw(summary)
              .write();

      - name: Post success comment to issue
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const sourceOrg = '${{ needs.validate.outputs.source_organization }}';
            const sourceRepo = '${{ needs.validate.outputs.source_repo }}';
            const targetOrg = '${{ needs.validate.outputs.target_organization }}';
            const targetRepo = '${{ needs.validate.outputs.target_repo }}';
            const targetVisibility = '${{ needs.validate.outputs.target_visibility }}';
            const admins = '${{ needs.validate.outputs.admins }}';
            const migrationOptions = '${{ needs.validate.outputs.migration_options }}';
            const issueNumber = '${{ needs.validate.outputs.issue_number }}';
            const runId = context.runId;
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const sourceBranches = '${{ needs.pre-migration.outputs.source_branches }}';
            const sourceTags = '${{ needs.pre-migration.outputs.source_tags }}';
            const sourceHeadSha = '${{ needs.pre-migration.outputs.source_head_sha }}';
            const defaultBranch = '${{ needs.pre-migration.outputs.source_default_branch }}';
            const archiveSource = '${{ needs.pre-migration.outputs.archive_source }}';

            let adminsSection = '';
            if (admins) {
              const adminList = admins.split(',').map(a => a.trim().replace(/^@/, '')).filter(a => a);
              adminsSection = '\n\n### üë§ Admin Access\n';
              for (const admin of adminList) {
                adminsSection += `- \`${admin}\` ‚Äî admin ‚úÖ\n`;
              }
            }

            let optionsSection = '';
            if (migrationOptions) {
              const options = migrationOptions.split(',').map(o => o.trim()).filter(o => o);
              if (options.length > 0) {
                optionsSection = '\n\n### ‚öôÔ∏è Migration Options Applied\n';
                for (const option of options) {
                  optionsSection += `- ‚úÖ ${option}\n`;
                }
              }
            }

            const commentBody = `## ‚úÖ GHEC Migration Completed Successfully!

            Your repository has been migrated from GitHub.com to GitHub.com via GEI.

            ### üéâ Migration Details
            - **Source Repository:** \`${sourceOrg}/${sourceRepo}\`
            - **Target Repository:** [${targetOrg}/${targetRepo}](https://github.com/${targetOrg}/${targetRepo})
            - **Target Visibility:** ${targetVisibility}
            - **Default Branch:** ${defaultBranch}
            - **Workflow Run:** [#${runId}](${runUrl})

            ### üìä Verification Results
            | Check | Source | Target | Status |
            |-------|--------|--------|--------|
            | **Branches** | ${sourceBranches} | ${sourceBranches} | ‚úÖ |
            | **Tags** | ${sourceTags} | ${sourceTags} | ‚úÖ |
            | **HEAD SHA** | \`${sourceHeadSha.substring(0, 12)}\` | \`${sourceHeadSha.substring(0, 12)}\` | ‚úÖ |

            ### üì¶ Post-Migration Actions
            - ${archiveSource === 'true' ? '‚úÖ Source repository archived after migration' : '‚è≠Ô∏è Source repository archiving was not requested'}
            - ‚úÖ Branch protection rules migrated from source
            - ‚úÖ Migration manifest updated${adminsSection}${optionsSection}

            ### ÔøΩ Secrets Requiring Manual Re-creation
            ${(() => {
              const sn = '${{ needs.post-migration.outputs.secret_names }}';
              const sc = '${{ needs.post-migration.outputs.secret_count }}';
              const se = '${{ needs.post-migration.outputs.secret_error }}';
              if (se) return `‚ö†Ô∏è Could not list secrets: ${se}`;
              if (!sc || sc === '0') return '‚úÖ No repository-level secrets to re-create.';
              let table = '| Secret Name | Scope |\n|-------------|-------|\n';
              const parts = sn.split(' | ');
              for (const part of parts) {
                const [scope, ...names] = part.split(': ');
                if (names.length > 0) {
                  for (const name of names.join(': ').split(', ')) {
                    table += `| \`${name.trim()}\` | ${scope} |\n`;
                  }
                }
              }
              return table + `\n> **Total: ${sc} secret(s)** ‚Äî Use \`gh secret set <NAME> --repo ${targetOrg}/${targetRepo}\` to re-create them.`;
            })()}

            ### üìã Next Steps
            1. Visit your migrated repository: https://github.com/${targetOrg}/${targetRepo}
            2. Verify repository contents and settings
            3. Review actor-specific branch protection settings (push restrictions, dismissal restrictions, bypass allowances, lock branch, deployments)
            4. Verify team access and collaborator permissions
            5. Re-create any secrets listed above
            6. Start developing! üöÄ

            ---
            *Automated by GitHub Actions workflow ‚Äî GEI migration applied successfully*`;

            await github.rest.issues.createComment({
              issue_number: parseInt(issueNumber),
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });
      - name: Close issue
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = '${{ needs.validate.outputs.issue_number }}';
            const sourceOrg = '${{ needs.validate.outputs.source_organization }}';
            const sourceRepo = '${{ needs.validate.outputs.source_repo }}';
            const targetOrg = '${{ needs.validate.outputs.target_organization }}';
            const targetRepo = '${{ needs.validate.outputs.target_repo }}';
            const sourceBranches = '${{ needs.pre-migration.outputs.source_branches }}';
            const sourceTags = '${{ needs.pre-migration.outputs.source_tags }}';
            const sourceHeadSha = '${{ needs.pre-migration.outputs.source_head_sha }}';
            const archiveSource = '${{ needs.pre-migration.outputs.archive_source }}';
            const targetUrl = `https://github.com/${targetOrg}/${targetRepo}`;

            let archiveMsg = '';
            if (archiveSource === 'true') {
              archiveMsg = '\n- üì¶ Source repository archived on GitHub.com';
            }

            const commentBody = `### üéâ Migration Completed Successfully!

            | Detail | Value |
            |--------|-------|
            | **Source (GitHub.com)** | \`${sourceOrg}/${sourceRepo}\` |
            | **Target (GitHub.com)** | [\`${targetOrg}/${targetRepo}\`](${targetUrl}) |
            | **Branches** | ${sourceBranches} |
            | **Tags** | ${sourceTags} |
            | **HEAD SHA** | \`${sourceHeadSha}\` |
            | **Verification** | ‚úÖ All checks passed |
            ${archiveMsg}

            The repository has been successfully migrated.`;

            // Post completion comment
            await github.rest.issues.createComment({
              issue_number: parseInt(issueNumber),
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });

            // Close issue
            await github.rest.issues.update({
              issue_number: parseInt(issueNumber),
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              state_reason: 'completed'
            });

            // Add completion label and remove in-progress
            try {
              await github.rest.issues.removeLabel({
                issue_number: parseInt(issueNumber),
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: 'in-progress'
              });
            } catch (e) {
              // Label may not exist, ignore
            }

            await github.rest.issues.addLabels({
              issue_number: parseInt(issueNumber),
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['completed']
            });
