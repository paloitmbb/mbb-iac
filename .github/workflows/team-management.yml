name: "Issue Triggered Team Management Workflow"

on:
  issues:
    types: [opened]

permissions:
  issues: write

jobs:
  # ============================================================================
  # Job 1: Validate Team Request
  # ============================================================================
  validate-request:
    name: Validate Team Request
    runs-on: ubuntu-latest
    if: contains(github.event.issue.labels.*.name, 'team-request')
    outputs:
      request-type: ${{ steps.parse.outputs.request-type }}
      team-name: ${{ steps.parse.outputs.team-name }}
      team-maintainer: ${{ steps.parse.outputs.team-maintainer }}
      repository: ${{ steps.parse.outputs.repository }}
      permission: ${{ steps.parse.outputs.permission }}
      justification: ${{ steps.parse.outputs.justification }}
      validation-passed: ${{ steps.validate.outputs.validation-passed }}
      errors: ${{ steps.validate.outputs.errors }}
      validations: ${{ steps.validate.outputs.validations }}

    steps:
      - name: Parse issue form
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const issueBody = context.payload.issue.body;

            function extractField(body, fieldLabel) {
              const regex = new RegExp(`### ${fieldLabel}\\s*\\n\\s*([^\\n#]+)`, 'i');
              const match = body.match(regex);
              return match ? match[1].trim() : '';
            }

            const requestType = extractField(issueBody, 'Request Type');
            const teamName = extractField(issueBody, 'Team');
            let teamMaintainer = extractField(issueBody, 'Team Maintainer');
            const repository = extractField(issueBody, 'Repository');
            const rawPermission = extractField(issueBody, 'Permission Level');
            const permission = (rawPermission && rawPermission !== '_No response_') ? rawPermission : 'push';
            const justification = extractField(issueBody, 'Justification / Remark');

            // Default team maintainer to requestor for maintainer role requests
            const isMaintainerRequest = requestType.toLowerCase().includes('maintainer');
            if (isMaintainerRequest && (!teamMaintainer || teamMaintainer === '_No response_')) {
              teamMaintainer = context.payload.issue.user.login;
            }

            core.setOutput('request-type', requestType);
            // Slugify team name and repository to avoid capitalisation mismatch with GitHub slugs
            core.setOutput('team-name', teamName ? teamName.toLowerCase().replace(/\s+/g, '-') : '');
            core.setOutput('team-maintainer', teamMaintainer || '');
            core.setOutput('repository', repository ? repository.toLowerCase().replace(/\s+/g, '-') : '');
            core.setOutput('permission', permission);
            core.setOutput('justification', justification);

            console.log(`Request Type: ${requestType}`);
            console.log(`Team Name: ${teamName}`);
            console.log(`Team Maintainer: ${teamMaintainer}`);
            console.log(`Repository: ${repository}`);
            console.log(`Permission: ${permission}`);

      - name: Validate team request
        id: validate
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_GITHUB_TOKEN }}
          script: |
            const org = context.repo.owner;
            const requestType = '${{ steps.parse.outputs.request-type }}';
            const teamName = '${{ steps.parse.outputs.team-name }}';
            const teamMaintainer = '${{ steps.parse.outputs.team-maintainer }}';
            const repository = '${{ steps.parse.outputs.repository }}';
            const errors = [];
            const validations = [];

            // --- Common Validations ---

            // Validate request type
            const validTypes = [
              'Request team maintainer role',
              'Remove team maintainer role',
              'Give team access to a repository',
              'Remove team access to a repository',
              'Create new team'
            ];
            if (!validTypes.includes(requestType)) {
              errors.push(`Invalid request type: "${requestType}". Must be one of: ${validTypes.join(', ')}`);
            } else {
              validations.push({ check: 'Request type is valid', result: '‚úÖ Passed' });
            }

            // Validate team name
            if (!teamName) {
              errors.push('Team name is required');
            } else if (!/^[a-zA-Z0-9._-]+$/.test(teamName)) {
              errors.push('Team name must contain only alphanumeric characters, hyphens, underscores, and periods');
            } else {
              validations.push({ check: 'Team name format', result: '‚úÖ Passed' });
            }

            // --- Team Existence Check ---
            let teamExists = false;
            if (teamName && /^[a-zA-Z0-9._-]+$/.test(teamName)) {
              try {
                await github.rest.teams.getByName({ org, team_slug: teamName });
                teamExists = true;
                const foundExpected = requestType !== 'Create new team';
                console.log(`${foundExpected ? '‚úÖ' : '‚ùå'} Team "${teamName}" found in organization`);
              } catch (e) {
                if (e.status === 404) {
                  teamExists = false;
                  const notFoundExpected = requestType === 'Create new team';
                  console.log(`${notFoundExpected ? '‚úÖ' : '‚ùå'} Team "${teamName}" not found in organization`);
                } else {
                  throw e;
                }
              }
            }

            // For "Create new team": team must NOT exist
            if (requestType === 'Create new team') {
              if (teamExists) {
                errors.push(`Team "${teamName}" already exists. Cannot create a duplicate.`);
                validations.push({ check: 'Team does not exist (required for create)', result: '‚ùå Team already exists' });
              } else {
                validations.push({ check: 'Team does not exist (required for create)', result: '‚úÖ Passed' });
              }
            } else if (validTypes.includes(requestType)) {
              // For all other requests: team MUST exist
              if (!teamExists) {
                errors.push(`Team "${teamName}" does not exist in the organization.`);
                validations.push({ check: 'Team exists', result: '‚ùå Not found' });
              } else {
                validations.push({ check: 'Team exists', result: '‚úÖ Passed' });
              }
            }

            // --- Username Validation (maintainer requests and optional for create new team) ---
            const isMaintainerRequest = requestType.includes('maintainer');
            const hasSpecifiedMaintainer = !!(teamMaintainer && teamMaintainer !== '_No response_');
            if (isMaintainerRequest || (requestType === 'Create new team' && hasSpecifiedMaintainer)) {
              if (isMaintainerRequest && !teamMaintainer) {
                errors.push('Team maintainer username is required for maintainer role requests');
              } else if (hasSpecifiedMaintainer) {
                // Check if user exists on GitHub
                try {
                  await github.rest.users.getByUsername({ username: teamMaintainer });
                  validations.push({ check: `User "${teamMaintainer}" exists`, result: '‚úÖ Passed' });
                } catch (e) {
                  errors.push(`User "${teamMaintainer}" does not exist on GitHub`);
                  validations.push({ check: `User "${teamMaintainer}" exists`, result: '‚ùå Not found' });
                }

                // Check org membership
                try {
                  await github.rest.orgs.checkMembershipForUser({ org, username: teamMaintainer });
                  validations.push({ check: `User "${teamMaintainer}" is org member`, result: '‚úÖ Passed' });
                } catch (e) {
                  errors.push(`User "${teamMaintainer}" is not a member of the organization`);
                  validations.push({ check: `User "${teamMaintainer}" is org member`, result: '‚ùå Not a member' });
                }
              }
            }

            // --- Repository Validation (team access requests only) ---
            const isAccessRequest = requestType.includes('access to a repository');
            if (isAccessRequest) {
              if (!repository || repository === '_No response_') {
                errors.push('Repository name is required for team access requests');
              } else {
                try {
                  await github.rest.repos.get({ owner: org, repo: repository });
                  validations.push({ check: `Repository "${repository}" exists`, result: '‚úÖ Passed' });
                } catch (e) {
                  errors.push(`Repository "${repository}" does not exist in the organization`);
                  validations.push({ check: `Repository "${repository}" exists`, result: '‚ùå Not found' });
                }
              }
            }

            // --- Output Results ---
            const passed = errors.length === 0;
            core.setOutput('validation-passed', passed.toString());
            core.setOutput('errors', JSON.stringify(errors));
            core.setOutput('validations', JSON.stringify(validations));

            console.log(`Validation ${passed ? 'PASSED' : 'FAILED'} - ${errors.length} error(s)`);

            if (!passed) {
              core.setFailed(`Validation failed with ${errors.length} error(s): ${errors.join('; ')}`);
            }

      - name: Post validation summary to issue
        if: always()
        uses: actions/github-script@v7
        env:
          ERRORS_JSON: ${{ steps.validate.outputs.errors }}
          VALIDATIONS_JSON: ${{ steps.validate.outputs.validations }}
        with:
          github-token: ${{ secrets.ORG_GITHUB_TOKEN }}
          script: |
            const passed = '${{ steps.validate.outputs.validation-passed }}' === 'true';
            const errors = JSON.parse(process.env.ERRORS_JSON || '[]');
            const validations = JSON.parse(process.env.VALIDATIONS_JSON || '[]');

            const requestType = `${{ steps.parse.outputs.request-type }}`;
            const teamName = `${{ steps.parse.outputs.team-name }}`;
            const teamMaintainer = `${{ steps.parse.outputs.team-maintainer }}`;
            const repository = `${{ steps.parse.outputs.repository }}`;
            const permission = `${{ steps.parse.outputs.permission }}`;

            let comment = passed
              ? '## ‚úÖ Validation Passed\n\n'
              : '## ‚ùå Validation Failed\n\n';

            // Request summary table
            comment += '### üìã Request Summary\n\n';
            comment += '| Field | Value |\n';
            comment += '|-------|-------|\n';
            comment += `| **Request Type** | ${requestType} |\n`;
            comment += `| **Team** | \`${teamName}\` |\n`;
            comment += `| **Team Maintainer** | ${teamMaintainer || '_N/A_'} |\n`;
            comment += `| **Repository** | ${repository || '_N/A_'} |\n`;
            comment += `| **Permission** | ${permission || '_N/A_'} |\n`;
            comment += `| **Requested By** | @${context.payload.issue.user.login} |\n\n`;

            // Validation results
            comment += '### üîç Validation Results\n\n';
            comment += '| Check | Result |\n';
            comment += '|-------|--------|\n';
            for (const v of validations) {
              comment += `| ${v.check} | ${v.result} |\n`;
            }
            comment += '\n';

            // Errors (if any)
            if (errors.length > 0) {
              comment += '### ‚ö†Ô∏è Errors\n\n';
              for (const e of errors) {
                comment += `- ‚ùå ${e}\n`;
              }
              comment += '\n';
            }

            // Next steps
            if (passed) {
              comment += '### üìù Next Steps\n\n';
              comment += '- ‚è≥ Awaiting approval from **DevSecOps team** (`paloitmbb-devsecops`)\n';
              comment += '- Once approved, the request will be executed automatically\n';
            } else {
              comment += '### üìù Next Steps\n\n';
              comment += '- Please fix the validation errors and create a new request issue.\n';
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment,
            });

            // Add labels
            const labels = passed ? ['validation-passed'] : ['validation-failed'];
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels,
            });

            // Close issue if validation failed
            if (!passed) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                state: 'closed',
                state_reason: 'not_planned',
              });
            }

      - name: Generate validation job summary
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const passed = '${{ steps.validate.outputs.validation-passed }}' === 'true';
            const requestType = `${{ steps.parse.outputs.request-type }}`;
            const teamName = `${{ steps.parse.outputs.team-name }}`;
            const issueNumber = context.issue.number;

            let summary = passed
              ? '# ‚úÖ Team Request Validation Passed\n\n'
              : '# ‚ùå Team Request Validation Failed\n\n';

            summary += '| Field | Value |\n';
            summary += '|-------|-------|\n';
            summary += `| **Request Type** | ${requestType} |\n`;
            summary += `| **Team** | \`${teamName}\` |\n`;
            summary += `| **Issue** | [#${issueNumber}](https://github.com/${context.repo.owner}/${context.repo.repo}/issues/${issueNumber}) |\n`;
            summary += `| **Requestor** | @${context.payload.issue.user.login} |\n`;
            summary += `| **Status** | ${passed ? '‚úÖ Passed' : '‚ùå Failed'} |\n\n`;

            if (passed) {
              summary += '## Next Steps\n\n';
              summary += '- Awaiting DevSecOps team approval\n';
              summary += '- Request will be executed automatically upon approval\n';
            }

            await core.summary.addRaw(summary).write();

  # ============================================================================
  # Job 2: Execute Team Request (Requires Approval)
  # ============================================================================
  execute-request:
    name: Execute Team Request
    runs-on: ubuntu-latest
    needs: validate-request
    if: needs.validate-request.outputs.validation-passed == 'true'
    environment: team-management-approval

    steps:
      - name: Execute team request
        id: execute
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_GITHUB_TOKEN }}
          script: |
            const org = context.repo.owner;
            const requestType = '${{ needs.validate-request.outputs.request-type }}';
            const teamName = '${{ needs.validate-request.outputs.team-name }}';
            const teamMaintainer = '${{ needs.validate-request.outputs.team-maintainer }}';
            const repository = '${{ needs.validate-request.outputs.repository }}';
            const permission = '${{ needs.validate-request.outputs.permission }}' || 'push';
            const hasSpecifiedMaintainer = !!(teamMaintainer && teamMaintainer !== '_No response_');
            let result = {};

            switch (requestType) {

              // ‚îÄ‚îÄ Request 1: Request team maintainer role ‚îÄ‚îÄ
              case 'Request team maintainer role':
                await github.rest.teams.addOrUpdateMembershipForUserInOrg({
                  org,
                  team_slug: teamName,
                  username: teamMaintainer,
                  role: 'maintainer',
                });
                result = {
                  action: 'Assigned maintainer role',
                  details: `User \`${teamMaintainer}\` is now a **maintainer** of team \`${teamName}\``,
                };
                break;

              // ‚îÄ‚îÄ Request 2: Remove team maintainer role ‚îÄ‚îÄ
              case 'Remove team maintainer role':
                await github.rest.teams.addOrUpdateMembershipForUserInOrg({
                  org,
                  team_slug: teamName,
                  username: teamMaintainer,
                  role: 'member',
                });
                result = {
                  action: 'Removed maintainer role',
                  details: `User \`${teamMaintainer}\` has been demoted to **member** of team \`${teamName}\``,
                };
                break;

              // ‚îÄ‚îÄ Request 3: Give team access to a repository ‚îÄ‚îÄ
              case 'Give team access to a repository':
                await github.rest.teams.addOrUpdateRepoPermissionsInOrg({
                  org,
                  team_slug: teamName,
                  owner: org,
                  repo: repository,
                  permission,
                });
                result = {
                  action: 'Granted repository access',
                  details: `Team \`${teamName}\` now has **${permission}** access to \`${repository}\``,
                };
                break;

              // ‚îÄ‚îÄ Request 4: Remove team access to a repository ‚îÄ‚îÄ
              case 'Remove team access to a repository':
                await github.rest.teams.removeRepoInOrg({
                  org,
                  team_slug: teamName,
                  owner: org,
                  repo: repository,
                });
                result = {
                  action: 'Removed repository access',
                  details: `Team \`${teamName}\` no longer has access to \`${repository}\``,
                };
                break;

              // ‚îÄ‚îÄ Request 5: Create new team ‚îÄ‚îÄ
              case 'Create new team': {
                const createResponse = await github.rest.teams.create({
                  org,
                  name: teamName,
                  privacy: 'closed',
                });

                // Use the slug returned by the API ‚Äî it may differ from the provided name
                // (e.g. spaces ‚Üí hyphens, uppercase ‚Üí lowercase, special chars stripped)
                const createdSlug = createResponse.data.slug;

                // Assign requestor as team maintainer
                const requestor = context.payload.issue.user.login;
                await github.rest.teams.addOrUpdateMembershipForUserInOrg({
                  org,
                  team_slug: createdSlug,
                  username: requestor,
                  role: 'maintainer',
                });

                // Also assign specified team maintainer if provided and different from requestor
                if (hasSpecifiedMaintainer && teamMaintainer !== requestor) {
                  await github.rest.teams.addOrUpdateMembershipForUserInOrg({
                    org,
                    team_slug: createdSlug,
                    username: teamMaintainer,
                    role: 'maintainer',
                  });
                }

                const extraMaintainerNote = hasSpecifiedMaintainer && teamMaintainer !== requestor
                  ? `. User \`@${teamMaintainer}\` also assigned as **maintainer**`
                  : '';
                result = {
                  action: 'Created new team',
                  details: `Team \`${teamName}\` created (slug: \`${createdSlug}\`). User \`@${requestor}\` assigned as **maintainer**${extraMaintainerNote}.`,
                };
                break;
              }

              default:
                throw new Error(`Unknown request type: ${requestType}`);
            }

            core.setOutput('action', result.action);
            core.setOutput('details', result.details);
            console.log(`‚úÖ ${result.action}: ${result.details}`);

      - name: Post execution summary to issue
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_GITHUB_TOKEN }}
          script: |
            const success = '${{ steps.execute.outcome }}' === 'success';
            const action = '${{ steps.execute.outputs.action }}' || 'Unknown action';
            const details = '${{ steps.execute.outputs.details }}' || 'No details available';

            let comment = success
              ? '## ‚úÖ Request Executed Successfully\n\n'
              : '## ‚ùå Request Execution Failed\n\n';

            comment += '### üìã Execution Summary\n\n';
            comment += '| Field | Value |\n';
            comment += '|-------|-------|\n';
            comment += `| **Action** | ${action} |\n`;
            comment += `| **Details** | ${details} |\n`;
            comment += `| **Executed By** | Automated Workflow |\n`;
            comment += `| **Approved By** | DevSecOps Team |\n`;

            comment += '\n';

            if (!success) {
              const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
              comment += `### üîß Troubleshooting\n\n`;
              comment += `- [View Workflow Logs](${runUrl})\n`;
              comment += `- Contact DevSecOps team for assistance\n`;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment,
            });

            // Close issue on success, add labels
            if (success) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                state: 'closed',
                state_reason: 'completed',
              });
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['completed'],
              });
            } else {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['execution-failed'],
              });
            }

      - name: Generate execution job summary
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const success = '${{ steps.execute.outcome }}' === 'success';
            const action = '${{ steps.execute.outputs.action }}' || 'Unknown';
            const details = '${{ steps.execute.outputs.details }}' || 'No details';
            const requestType = '${{ needs.validate-request.outputs.request-type }}';
            const teamName = '${{ needs.validate-request.outputs.team-name }}';
            const issueNumber = context.issue.number;

            let summary = success
              ? '# ‚úÖ Team Request Executed Successfully\n\n'
              : '# ‚ùå Team Request Execution Failed\n\n';

            summary += '| Field | Value |\n';
            summary += '|-------|-------|\n';
            summary += `| **Request Type** | ${requestType} |\n`;
            summary += `| **Team** | \`${teamName}\` |\n`;
            summary += `| **Action** | ${action} |\n`;
            summary += `| **Details** | ${details} |\n`;
            summary += `| **Issue** | [#${issueNumber}](https://github.com/${context.repo.owner}/${context.repo.repo}/issues/${issueNumber}) |\n`;

            summary += '\n';

            if (!success) {
              const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
              summary += `## üîß Troubleshooting\n\n`;
              summary += `- [View Workflow Logs](${runUrl})\n`;
              summary += `- Contact DevSecOps team for assistance\n`;
            }

            await core.summary.addRaw(summary).write();
